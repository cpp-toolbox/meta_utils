#include "meta_utils.hpp"
#include <iostream>
#include <optional>
#include <vector>

namespace meta_utils {

// NOTE: this needs to get autogenerated
// the return type needs to be autogenerated as well...
std::vector<float> parse_vector_of_type(const std::string &input) {
    std::string trimmed = input;

    // Remove surrounding curly braces if present
    if (!trimmed.empty() && trimmed.front() == '{' && trimmed.back() == '}') {
        trimmed = trimmed.substr(1, trimmed.size() - 2);
    }

    std::vector<float> result;
    std::stringstream ss(trimmed);
    std::string element;

    while (std::getline(ss, element, ',')) {
        // Trim whitespace
        element.erase(std::remove_if(element.begin(), element.end(), ::isspace), element.end());

        if (!element.empty()) {
            try {
                auto conversion = [](std::string s) { return std::stof(s); };
                // NOTE: HERE we need to autogenerate this part to call the MetaTypes conversion function
                result.push_back(conversion(element));
            } catch (...) {
                // Invalid float, ignore or handle as needed
            }
        }
    }

    return result;
}

std::string create_string_to_vector_of_type_func(MetaType type_parameter) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("std::vector<", type_parameter.name, "> parse_vector_of_type(const std::string &input) {");
    msa.add("    std::string trimmed = input;");
    msa.add("");

    msa.add("    // Remove surrounding curly braces if present");
    msa.add("    if (!trimmed.empty() && trimmed.front() == '{' && trimmed.back() == '}') {");
    msa.add("        trimmed = trimmed.substr(1, trimmed.size() - 2);");
    msa.add("    }");
    msa.add("");

    msa.add("    std::vector<", type_parameter.name, "> result;");
    msa.add("    std::regex element_re(R\"(", type_parameter.literal_regex, ")\");");
    msa.add("    auto begin = std::sregex_iterator(trimmed.begin(), trimmed.end(), element_re);");
    msa.add("    auto end = std::sregex_iterator();");
    msa.add("");

    msa.add("    for (auto it = begin; it != end; ++it) {");
    msa.add("        try {");
    msa.add("            auto conversion = ", type_parameter.string_to_type_func, ";");
    msa.add("            result.push_back(conversion(it->str()));");
    msa.add("        } catch (...) {");
    msa.add("            // Ignore malformed elements");
    msa.add("        }");
    msa.add("    }");
    msa.add("");

    msa.add("    return result;");
    msa.add("}");

    MetaFunction mf(msa.str());

    return mf.to_lambda_string();
}

std::string create_vector_of_type_to_string_func(MetaType type_parameter) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("std::string f(const std::vector<", type_parameter.name, ">& vec) {");
    msa.add("    std::ostringstream oss;");
    msa.add("    oss << \"{\";");
    msa.add("");
    msa.add("    auto conversion = ", type_parameter.type_to_string_func, ";");
    msa.add("");
    msa.add("    for (size_t i = 0; i < vec.size(); ++i) {");
    msa.add("        oss << conversion(vec[i]);");
    msa.add("        if (i + 1 < vec.size())");
    msa.add("            oss << \", \";");
    msa.add("    }");
    msa.add("");
    msa.add("    oss << \"}\";");
    msa.add("    return oss.str();");
    msa.add("}");

    MetaFunction mf(msa.str());
    return mf.to_lambda_string();
}

// Extracts top-level comma-separated substrings from inside <...>
// e.g., split_template_args("int, std::vector<float>, std::map<int, double>")
//   â†’ ["int", "std::vector<float>", "std::map<int, double>"]
std::vector<std::string> split_template_args(const std::string &s) {
    std::vector<std::string> args;
    int depth = 0;
    std::string current;

    for (char c : s) {
        if (c == '<') {
            depth++;
            current += c;
        } else if (c == '>') {
            depth--;
            current += c;
        } else if (c == ',' && depth == 0) {
            args.push_back(text_utils::trim(current));
            current.clear();
        } else {
            current += c;
        }
    }

    if (!current.empty()) {
        args.push_back(text_utils::trim(current));
    }

    return args;
}

std::string trim(const std::string &s) {
    size_t start = s.find_first_not_of(" \t\n\r");
    if (start == std::string::npos)
        return "";
    size_t end = s.find_last_not_of(" \t\n\r");
    return s.substr(start, end - start + 1);
}

std::vector<std::string> split_args(const std::string &args_str) {
    std::vector<std::string> args;
    std::string current;
    int depth = 0;
    for (char c : args_str) {
        if (c == ',' && depth == 0) {
            args.push_back(trim(current));
            current.clear();
        } else {
            if (c == '<' || c == '(')
                depth++;
            else if (c == '>' || c == ')')
                depth--;
            current += c;
        }
    }
    if (!current.empty())
        args.push_back(trim(current));
    return args;
}

std::string generate_regex_to_match_valid_invocation_of_func(const std::string &signature) {
    // Parse signature: return_type func_name(arg_type arg_name, ...)
    std::smatch match;
    if (!std::regex_match(signature, match, regex_utils::function_signature_re)) {
        throw std::invalid_argument("Invalid function signature");
    }

    std::string return_type = text_utils::trim(match[1]);
    std::string func_name = match[2];
    std::string args_str = match[3];

    auto args = split_args(args_str);

    std::vector<std::string> arg_types;

    for (auto &arg : args) {
        if (arg.empty())
            continue;
        size_t space_pos = arg.rfind(' ');
        if (space_pos == std::string::npos) {
            throw std::invalid_argument("Each argument must have type and name");
        }
        arg_types.push_back(arg.substr(0, space_pos));
    }

    // Build regex pattern for argument parsing
    std::vector<std::string> argument_literal_regexes;

    std::vector<MetaType> extended_types = meta_utils::concrete_types;
    MetaType glm_vec3_type("glm::vec3", "[](const std::string &s) { return glm_utils::parse_vec3(s); }",
                           "[](const glm::vec3 &v) { return vec3_to_string(v); }", regex_utils::float_triplet);

    MetaType glm_vec2_type("glm::vec2", "[](const std::string &s) { return glm_utils::parse_vec2(s); }",
                           "[](const glm::vec2 &v) { return vec2_to_string(v); }", regex_utils::float_tuple);

    extended_types.push_back(glm_vec3_type);
    extended_types.push_back(glm_vec2_type);

    auto extended_type_name_to_meta_type = meta_utils::create_type_name_to_meta_type_map(extended_types);

    for (const auto &typ : arg_types) {
        auto mt = meta_utils::parse_meta_type_from_string(typ, extended_type_name_to_meta_type).value();
        argument_literal_regexes.push_back(regex_utils::capture(mt.literal_regex));
    }

    std::string function_invocation_regex = text_utils::join(
        {regex_utils::start_of_line, func_name, "\\(",
         text_utils::join(argument_literal_regexes, regex_utils::optional_ws + "," + regex_utils::optional_ws), "\\)",
         regex_utils::end_of_line},
        regex_utils::optional_ws);

    return function_invocation_regex;
}

std::optional<MetaType>
parse_meta_type_from_string(const std::string &type_str,
                            std::unordered_map<std::string, MetaType> concrete_type_name_to_meta_type) {

    std::string s = text_utils::trim(type_str);

    if (auto it = concrete_type_name_to_meta_type.find(s); it != concrete_type_name_to_meta_type.end()) {
        return it->second;
    }

    // now we know that the type is a generic type

    // try to match template type: base<...>
    static const std::regex template_regex(R"((\w+(?:::\w+)*)\s*<\s*([^<>]+(?:<[^<>]+>[^<>]*)*)\s*>)");
    std::smatch match;
    if (std::regex_match(s, match, template_regex)) {
        std::string base_type = match[1].str(); // e.g., "std::vector"
        std::string args_str = match[2].str();  // e.g., "int" or "std::string, std::vector<int>"

        // parse argument types recursively
        std::vector<std::string> inner_type_strs = split_template_args(args_str);
        std::vector<MetaType> inner_types;

        for (const std::string &arg_str : inner_type_strs) {
            auto maybe_inner = parse_meta_type_from_string(arg_str, concrete_type_name_to_meta_type);
            if (!maybe_inner)
                return std::nullopt; // fail if any inner type is unknown
            inner_types.push_back(*maybe_inner);
        }

        // NOTE: only having support for vector right now.
        MetaType mt = meta_utils::generic_type_to_metatype_constructor.at(base_type)(inner_types.at(0));

        return mt;
    } else {
        std::cout << "regex didn't match : " << type_str << std::endl;
    }

    return std::nullopt;
}

std::string generate_invoker(const std::string &signature, const std::vector<MetaType> available_types) {
    // Parse signature: return_type func_name(arg_type arg_name, ...)
    std::smatch match;
    if (!std::regex_match(signature, match, regex_utils::function_signature_re)) {
        throw std::invalid_argument("Invalid function signature");
    }

    std::string return_type = text_utils::trim(match[1]);
    std::string func_name = match[2];
    std::string args_str = match[3];

    auto args = split_args(args_str);

    std::vector<std::string> arg_types;
    std::vector<std::string> arg_names;

    for (auto &arg : args) {
        if (arg.empty())
            continue;
        size_t space_pos = arg.rfind(' ');
        if (space_pos == std::string::npos) {
            throw std::invalid_argument("Each argument must have type and name");
        }
        arg_types.push_back(arg.substr(0, space_pos));
        arg_names.push_back(arg.substr(space_pos + 1));
    }

    std::vector<std::string> lambda_conversions;
    std::vector<std::string> arg_to_var_conversions;
    std::vector<std::string> call_to_actual_func_args;

    auto extended_type_name_to_meta_type = meta_utils::create_type_name_to_meta_type_map(available_types);

    for (size_t i = 0; i < arg_types.size(); i++) {
        const auto &typ = arg_types[i];
        const auto &name = arg_names[i];
        int group_num = (int)i + 1;

        auto mt = meta_utils::parse_meta_type_from_string(typ, extended_type_name_to_meta_type).value();

        std::string conversion_func_name = "conversion" + std::to_string(group_num);
        lambda_conversions.push_back("    auto " + conversion_func_name + " = " + mt.string_to_type_func + ";");

        std::string variable_assigment_to_conversion =
            "    " + typ + " " + name + " = " + conversion_func_name + "(match[" + std::to_string(group_num) + "]);";

        arg_to_var_conversions.push_back(variable_assigment_to_conversion);

        call_to_actual_func_args.push_back(name);
    }

    std::string function_invocation_regex = meta_utils::generate_regex_to_match_valid_invocation_of_func(signature);
    // Compose the final code
    text_utils::MultilineStringAccumulator msa;

    msa.add("std::optional<std::string> f(const std::string &input) {");
    msa.add("    std::regex re(R\"(", function_invocation_regex, ")\");");
    msa.add("    std::smatch match;");
    msa.add("    if (!std::regex_match(input, match, re)) return std::nullopt;");
    msa.add("");

    for (int i = 0; i < arg_to_var_conversions.size(); ++i) {
        auto lambda_conversion = lambda_conversions.at(i);
        auto conversion = arg_to_var_conversions.at(i);
        msa.add(lambda_conversion);
        msa.add(conversion);
    }

    msa.add("");

    // Call actual function
    msa.add("    ", return_type, " result = ", func_name, "(", text_utils::join(call_to_actual_func_args, ", "), ");");

    // Handle return
    if (return_type == "void") {
        msa.add("    return std::string(); // void returns empty string");
    } else if (return_type == "std::string") {
        msa.add("    return result;");
    } else {
        std::string return_type_to_string_func =
            meta_utils::parse_meta_type_from_string(return_type, extended_type_name_to_meta_type)
                .value()
                .type_to_string_func;
        msa.add("    auto conversion = ", return_type_to_string_func, ";");
        msa.add("    return conversion(result);");
    }
    msa.add("}");

    return msa.str();
}

// Helper join function for vector<string>
std::string join(const std::vector<std::string> &v, const std::string &sep) {
    std::string res;
    for (size_t i = 0; i < v.size(); i++) {
        res += v[i];
        if (i + 1 < v.size())
            res += sep;
    }
    return res;
}

} // namespace meta_utils
