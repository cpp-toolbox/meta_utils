#include "meta_utils.hpp"
#include <filesystem>
#include <iostream>
#include <optional>
#include <vector>
#include <algorithm> // for std::remove_if

namespace meta_utils {

// NOTE: this needs to get autogenerated
// the return type needs to be autogenerated as well...
std::vector<float> parse_vector_of_type(const std::string &input) {
    std::string trimmed = input;

    // Remove surrounding curly braces if present
    if (!trimmed.empty() && trimmed.front() == '{' && trimmed.back() == '}') {
        trimmed = trimmed.substr(1, trimmed.size() - 2);
    }

    std::vector<float> result;
    std::stringstream ss(trimmed);
    std::string element;

    while (std::getline(ss, element, ',')) {
        // Trim whitespace
        element.erase(std::remove_if(element.begin(), element.end(), ::isspace), element.end());

        if (!element.empty()) {
            try {
                auto conversion = [](std::string s) { return std::stof(s); };
                // NOTE: HERE we need to autogenerate this part to call the MetaTypes conversion function
                result.push_back(conversion(element));
            } catch (...) {
                // Invalid float, ignore or handle as needed
            }
        }
    }

    return result;
}

std::string create_string_to_vector_of_type_func(MetaType type_parameter) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::string &input) -> std::vector<", type_parameter.get_type_name(), "> {");
    msa.add("    std::string trimmed = input;");
    msa.add("    if (!trimmed.empty() && trimmed.front() == '{' && trimmed.back() == '}') {");
    msa.add("        trimmed = trimmed.substr(1, trimmed.size() - 2);");
    msa.add("    }");
    msa.add("");
    msa.add("    std::vector<", type_parameter.get_type_name(), "> result;");
    msa.add("    std::regex element_re(R\"(", type_parameter.literal_regex, ")\");");
    msa.add("    auto begin = std::sregex_iterator(trimmed.begin(), trimmed.end(), element_re);");
    msa.add("    auto end = std::sregex_iterator();");
    msa.add("");
    msa.add("    for (auto it = begin; it != end; ++it) {");
    msa.add("        try {");
    msa.add("            auto conversion = ", type_parameter.string_to_type_func, ";");
    msa.add("            result.push_back(conversion(it->str()));");
    msa.add("        } catch (...) {");
    msa.add("            // Ignore malformed elements");
    msa.add("        }");
    msa.add("    }");
    msa.add("    return result;");
    msa.add("}");

    return msa.str();
}

std::string create_vector_of_type_to_string_func(MetaType type_parameter) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::vector<", type_parameter.get_type_name(), ">& vec) -> std::string {");
    msa.add("    std::ostringstream oss;");
    msa.add("    oss << \"{\";");
    msa.add("    auto conversion = ", type_parameter.type_to_string_func, ";");
    msa.add("");
    msa.add("    for (size_t i = 0; i < vec.size(); ++i) {");
    msa.add("        oss << conversion(vec[i]);");
    msa.add("        if (i + 1 < vec.size())");
    msa.add("            oss << \", \";");
    msa.add("    }");
    msa.add("");
    msa.add("    oss << \"}\";");
    msa.add("    return oss.str();");
    msa.add("}");

    return msa.str();
}

// Extracts top-level comma-separated substrings from inside <...>
// e.g., split_template_args("int, std::vector<float>, std::map<int, double>")
//   â†’ ["int", "std::vector<float>", "std::map<int, double>"]
std::vector<std::string> split_template_args(const std::string &s) {
    std::vector<std::string> args;
    int depth = 0;
    std::string current;

    for (char c : s) {
        if (c == '<') {
            depth++;
            current += c;
        } else if (c == '>') {
            depth--;
            current += c;
        } else if (c == ',' && depth == 0) {
            args.push_back(text_utils::trim(current));
            current.clear();
        } else {
            current += c;
        }
    }

    if (!current.empty()) {
        args.push_back(text_utils::trim(current));
    }

    return args;
}

std::string trim(const std::string &s) {
    size_t start = s.find_first_not_of(" \t\n\r");
    if (start == std::string::npos)
        return "";
    size_t end = s.find_last_not_of(" \t\n\r");
    return s.substr(start, end - start + 1);
}

std::vector<std::string> split_args(const std::string &args_str) {
    std::vector<std::string> args;
    std::string current;
    int depth = 0;
    for (char c : args_str) {
        if (c == ',' && depth == 0) {
            args.push_back(trim(current));
            current.clear();
        } else {
            if (c == '<' || c == '(')
                depth++;
            else if (c == '>' || c == ')')
                depth--;
            current += c;
        }
    }
    if (!current.empty())
        args.push_back(trim(current));
    return args;
}

std::string simplify_parameter(const std::string &param_str) {
    std::string s = param_str;

    // Remove default value
    auto eq_pos = s.find('=');
    if (eq_pos != std::string::npos)
        s = s.substr(0, eq_pos);

    // Trim
    auto trim = [](std::string &str) {
        str.erase(str.begin(),
                  std::find_if(str.begin(), str.end(), [](unsigned char ch) { return !std::isspace(ch); }));
        str.erase(std::find_if(str.rbegin(), str.rend(), [](unsigned char ch) { return !std::isspace(ch); }).base(),
                  str.end());
    };
    trim(s);

    // Remove leading "const "
    if (s.rfind("const ", 0) == 0)
        s = s.substr(6);

    // Tokenize
    std::istringstream iss(s);
    std::vector<std::string> tokens;
    std::string token;
    while (iss >> token)
        tokens.push_back(token);

    if (tokens.size() < 1)
        throw std::runtime_error("Invalid parameter: " + param_str);

    // Get the name token
    std::string name = tokens.back();
    tokens.pop_back();

    // If name is prefixed with & or *, put that back into the type
    std::string symbol_prefix;
    while (!name.empty() && (name[0] == '&' || name[0] == '*')) {
        symbol_prefix += name[0];
        name = name.substr(1);
    }

    // Reconstruct type
    std::string type;
    for (const auto &t : tokens)
        type += (type.empty() ? "" : " ") + t;

    type += symbol_prefix;

    // Remove all & and * from type
    type.erase(std::remove_if(type.begin(), type.end(), [](char c) { return c == '&' || c == '*'; }), type.end());

    trim(type);
    return type + " " + name;
}

std::string generate_regex_to_match_valid_invocation_of_func(
    const std::string &signature, const std::unordered_map<std::string, MetaType> &concrete_type_name_to_meta_type) {
    // Parse signature: return_type func_name(arg_type arg_name, ...)

    std::string return_type, func_name, args_str;

    std::regex re(regex_utils::function_signature_ree);
    std::smatch match;
    if (!std::regex_match(signature, match, re)) {

        std::cout << signature << " | " << regex_utils::function_signature_ree << std::endl;
        std::regex re(regex_utils::constructor_signature_re);
        if (!std::regex_match(signature, match, re)) {

            throw std::invalid_argument("Invalid function or constructor signature");
        } else { // we have a constructor

            return_type = match[1];
            func_name = match[1];
            args_str = match[2];
        }
    } else {
        return_type = text_utils::trim(match[1]);
        func_name = match[3];
        args_str = match[4];
    }

    auto args = split_args(args_str);

    std::vector<std::string> arg_types;

    static const std::regex param_re(R"(^\s*(.+?)\s+(\w+)(\s*=.*)?$)");

    for (auto &arg : args) {
        if (arg.empty())
            continue;

        arg = simplify_parameter(arg);

        std::smatch match;
        if (!std::regex_match(arg, match, param_re)) {
            throw std::invalid_argument("Each argument must match format: 'Type Name [= default]'. Got: " + arg);
        }

        std::string raw_type_str = match[1];
        std::string name = match[2];
        // std::string default_value = match[3]; // (optional) if needed later

        std::string cleaned_type_str = clean_type_string(raw_type_str);

        arg_types.push_back(cleaned_type_str);
    }

    // Build regex pattern for argument parsing
    std::vector<std::string> argument_literal_regexes;

    for (const auto &typ : arg_types) {
        auto mt = meta_utils::parse_meta_type_from_string(typ, concrete_type_name_to_meta_type).value();
        argument_literal_regexes.push_back(regex_utils::capture(mt.literal_regex));
    }

    std::string function_invocation_regex = text_utils::join(
        {regex_utils::start_of_line, func_name, "\\(",
         text_utils::join(argument_literal_regexes, regex_utils::optional_ws + "," + regex_utils::optional_ws), "\\)",
         regex_utils::end_of_line},
        regex_utils::optional_ws);

    return function_invocation_regex;
}

std::optional<MetaType>
parse_meta_type_from_string(const std::string &type_str,
                            std::unordered_map<std::string, MetaType> concrete_type_name_to_meta_type) {

    std::string s = clean_type_string(type_str);

    if (auto it = concrete_type_name_to_meta_type.find(s); it != concrete_type_name_to_meta_type.end()) {
        return it->second;
    } // now we know that the type is a generic type

    // try to match template type: base<...>
    static const std::regex template_regex(R"((\w+(?:::\w+)*)\s*<\s*([^<>]+(?:<[^<>]+>[^<>]*)*)\s*>)");
    std::smatch match;
    if (std::regex_match(s, match, template_regex)) {

        std::string base_type = match[1].str(); // e.g., "std::vector"
        std::string args_str = match[2].str();  // e.g., "int" or "std::string, std::vector<int>"

        // parse argument types recursively
        std::vector<std::string> inner_type_strs = split_template_args(args_str);
        std::vector<MetaType> inner_types;

        for (const std::string &arg_str : inner_type_strs) {

            auto maybe_inner = parse_meta_type_from_string(arg_str, concrete_type_name_to_meta_type);

            if (!maybe_inner)
                return std::nullopt; // fail if any inner type is unknown
            inner_types.push_back(*maybe_inner);
        }

        // NOTE: only having support for vector right now.
        MetaType mt = meta_utils::generic_type_to_metatype_constructor.at(base_type)(inner_types.at(0));

        return mt;
    } else {
        std::cout << "regex didn't match : " << type_str << std::endl;
    }

    return std::nullopt;
}

std::string clean_type_string(const std::string &raw_type) {
    std::string s = raw_type;

    // Remove 'const', 'volatile', '&', '*'
    static const std::regex modifiers(R"(\bconst\b|\bvolatile\b|&|\*)");
    s = std::regex_replace(s, modifiers, "");

    // Remove extra whitespace
    static const std::regex extra_spaces(R"(\s+)");
    s = std::regex_replace(s, extra_spaces, " ");

    // Trim leading/trailing space
    if (!s.empty() && s.front() == ' ')
        s.erase(s.begin());
    if (!s.empty() && s.back() == ' ')
        s.pop_back();

    return s;
}

std::string generate_string_invoker_for_function_with_string_return_type(const MetaFunctionSignature &sig,
                                                                         const std::vector<MetaType> &available_types) {
    const std::string &return_type = sig.return_type;
    const std::string &func_name = sig.name;

    auto extended_type_name_to_meta_type = meta_utils::create_type_name_to_meta_type_map(available_types);

    // Find the type_to_string_func for the return type (except void)
    std::string return_type_to_string_func;
    if (return_type != "void" && return_type != "std::string") {
        auto meta_type_opt = meta_utils::parse_meta_type_from_string(return_type, extended_type_name_to_meta_type);
        if (!meta_type_opt) {
            throw std::runtime_error("Unknown return type: " + return_type);
        }
        return_type_to_string_func = meta_type_opt.value().type_to_string_func;
    }

    // Compose the new function name
    std::string new_func_name = func_name + "_string_invoker_to_string";

    text_utils::MultilineStringAccumulator msa;

    msa.add("std::optional<std::string> ", new_func_name, "(const std::string &input) {");
    msa.add("    auto opt_result = ", func_name, "_string_invoker(input);");
    msa.add("    if (!opt_result) return std::nullopt;");

    if (return_type == "void") {
        msa.add("    return std::string(); // void returns empty string");
    } else if (return_type == "std::string") {
        msa.add("    return *opt_result;");
    } else {
        msa.add("    auto conversion = ", return_type_to_string_func, ";");
        msa.add("    return conversion(*opt_result);");
    }

    msa.add("}");

    return msa.str();
}

std::string generate_string_invoker_for_function(const MetaFunctionSignature &sig,
                                                 const std::vector<MetaType> &available_types,
                                                 const std ::string &func_postfix) {
    const auto &params = sig.parameters;

    std::vector<std::string> lambda_conversions;
    std::vector<std::string> arg_to_var_conversions;
    std::vector<std::string> call_to_actual_func_args;

    auto extended_type_name_to_meta_type = meta_utils::create_type_name_to_meta_type_map(available_types);

    for (size_t i = 0; i < params.size(); i++) {
        const auto &param = params[i];
        const std::string &typ = param.type.get_type_name();
        const std::string &name = param.name;
        int group_num = static_cast<int>(i + 1);

        const std::string &string_to_type_func = param.type.string_to_type_func;

        std::string conversion_func_name = "conversion" + std::to_string(group_num);
        lambda_conversions.push_back("    auto " + conversion_func_name + " = " + string_to_type_func + ";");

        std::string variable_assignment =
            "    " + typ + " " + name + " = " + conversion_func_name + "(match[" + std::to_string(group_num) + "]);";

        arg_to_var_conversions.push_back(variable_assignment);
        call_to_actual_func_args.push_back(name);
    }

    std::string function_invocation_regex = sig.invocation_regex;

    text_utils::MultilineStringAccumulator msa;

    // NOTE: we use the camel case because sometimes we operate on constructors which are in camel case
    msa.add("std::optional<", sig.return_type, "> ", text_utils::camel_to_snake_case(sig.name), func_postfix,
            "(const std::string &input) {");
    msa.add("    std::regex re(R\"(", function_invocation_regex, ")\");");
    msa.add("    std::smatch match;");
    msa.add("    if (!std::regex_match(input, match, re)) return std::nullopt;");
    msa.add("");

    for (size_t i = 0; i < arg_to_var_conversions.size(); ++i) {
        msa.add(lambda_conversions[i]);
        msa.add(arg_to_var_conversions[i]);
    }

    msa.add("");

    // call actual function
    msa.add("    ", sig.return_type, " result = ", sig.get_fully_qualified_name(), "(",
            text_utils::join(call_to_actual_func_args, ", "), ");");
    msa.add("    return result;");

    msa.add("}");
    return msa.str();
}

// Helper join function for vector<string>
std::string join(const std::vector<std::string> &v, const std::string &sep) {
    std::string res;
    for (size_t i = 0; i < v.size(); i++) {
        res += v[i];
        if (i + 1 < v.size())
            res += sep;
    }
    return res;
}

// TODO: the below two functions are simply mappings, create a generic map function in collection utils one day
std::vector<MetaFunction>
generate_string_invokers_to_string(std::vector<MetaFunction> mfs,
                                   const std::vector<meta_utils::MetaType> &extended_types,
                                   std::unordered_map<std::string, MetaType> type_name_to_meta_type_map) {

    std::vector<MetaFunction> new_mfs;
    for (const auto &mf : mfs) {
        auto invoker_str_return_str =
            meta_utils::generate_string_invoker_for_function_with_string_return_type(mf.signature, extended_types);
        meta_utils::MetaFunction invoker_return_string(invoker_str_return_str, type_name_to_meta_type_map);
        new_mfs.push_back(invoker_str_return_str);
    }

    return new_mfs;
}

std::vector<MetaFunction>
generate_string_invokers(std::vector<MetaFunction> mfs, const std::vector<meta_utils::MetaType> &extended_types,
                         std::unordered_map<std::string, MetaType> type_name_to_meta_type_map) {

    std::vector<MetaFunction> new_mfs;
    for (const auto &mf : mfs) {
        auto invoker_str = meta_utils::generate_string_invoker_for_function(mf.signature, extended_types);
        meta_utils::MetaFunction invoker(invoker_str, type_name_to_meta_type_map);
        new_mfs.push_back(invoker);
    }

    return new_mfs;
}

std::string generate_string_invoker_for_function_collection(const MetaFunctionCollection &mfc) {
    std::ostringstream oss;

    oss << "std::optional<std::string> invoke(const std::string &invocation, std::vector<meta_utils::MetaType> "
           "available_types) "
           "{\n\n";
    oss << "    auto type_name_to_meta_type_map = meta_utils::create_type_name_to_meta_type_map(available_types);\n";

    // Generate MetaFunctionSignature declarations
    for (const auto &func : mfc.functions) {
        oss << "    meta_utils::MetaFunctionSignature mfs_" << func.signature.name << "(\""
            << func.signature.return_type << " " << func.signature.name << "(";

        for (size_t i = 0; i < func.signature.parameters.size(); ++i) {
            const auto &param = func.signature.parameters[i];
            oss << param.type.get_type_name() << " " << param.name;
            if (i < func.signature.parameters.size() - 1)
                oss << ", ";
        }

        oss << ")\", \"" << func.name_space << "\", type_name_to_meta_type_map);\n";
    }

    oss << "\n";

    // Generate if-else chain for invocation matching
    for (const auto &func : mfc.functions) {
        oss << "    if (std::regex_match(invocation, std::regex(mfs_" << func.signature.name
            << ".invocation_regex))) {\n";
        oss << "        return " << func.signature.name << "_string_invoker_to_string(invocation);\n";
        oss << "    }\n";
    }

    oss << "\n    return \"No matching function signature.\";\n";
    oss << "}\n";

    return oss.str();
}

void generate_string_invokers_from_source_code(const std::string &input_header_path,
                                               const std::string &input_source_path,
                                               const std::vector<meta_utils::MetaType> &extended_types,
                                               bool create_top_level_invoker,
                                               const std::vector<std::string> &string_signatures, FilterMode mode) {

    const std::string output_name_prefix = "string_invoker_";

    auto type_name_to_meta_type_map = meta_utils::create_type_name_to_meta_type_map(extended_types);

    meta_utils::MetaFunctionCollection input_collection(input_header_path, input_source_path,
                                                        type_name_to_meta_type_map, string_signatures, mode);

    meta_utils::MetaFunctionCollection output_collection;
    output_collection.name = output_name_prefix + input_collection.name;
    output_collection.includes_required_for_declaration =
        get_system_headers(input_collection.includes_required_for_declaration);

    output_collection.includes_required_for_declaration.push_back(meta_utils::string_include);
    output_collection.includes_required_for_declaration.push_back(meta_utils::optional_include);

    std::filesystem::path input_header_dir = std::filesystem::path(input_header_path).parent_path();
    std::filesystem::path output_dir = input_header_dir / "string_invoker";

    auto rel_path = fs_utils::get_relative_path(output_dir, "src/utility/meta_utils/meta_utils.hpp");

    output_collection.includes_required_for_declaration.push_back("#include \"" + std::string(rel_path) + "\"");
    output_collection.includes_required_for_declaration.push_back(
        "#include \"../" + std::filesystem::path(input_header_path).filename().string() + "\"");

    auto rel_glm_utils_path = fs_utils::get_relative_path(output_dir, "src/utility/glm_utils/glm_utils.hpp");
    auto rel_glm_printing_path = fs_utils::get_relative_path(output_dir, "src/utility/glm_printing/glm_printing.hpp");

    output_collection.includes_required_for_definition = {
        "#include \"" + std::filesystem::path(input_header_path).filename().string() + "\"",
        "#include \"../" + std::filesystem::path(input_header_path).filename().string() + "\"",
        "#include \"" + std::string(rel_glm_utils_path) + "\"",
        "#include \"" + std::string(rel_glm_printing_path) + "\"", meta_utils::regex_include};

    if (create_top_level_invoker) {
        auto full_invoker_str = meta_utils::generate_string_invoker_for_function_collection(input_collection);
        meta_utils::MetaFunction full_invoker(full_invoker_str, type_name_to_meta_type_map);
        output_collection.add_function(full_invoker);
        output_collection.add_function(generate_interactive_invoker(extended_types));
    }

    auto all_needed_functions =
        generate_string_invokers(input_collection.functions, extended_types, type_name_to_meta_type_map);

    if (create_top_level_invoker) {
        auto string_invoker_to_strings =
            generate_string_invokers_to_string(input_collection.functions, extended_types, type_name_to_meta_type_map);
        for (const auto inv : string_invoker_to_strings) {
            all_needed_functions.push_back(inv);
        }
    }

    for (const auto &si : all_needed_functions) {
        output_collection.add_function(si);
    }

    std::string header_str = output_collection.generate_header_file_string();
    std::string cpp_str = output_collection.generate_cpp_file_string();

    // use same base name as input header/source for output file names
    std::string base_filename = std::filesystem::path(input_header_path).stem().string();

    std::filesystem::path output_header = output_dir / (base_filename + ".hpp");
    std::filesystem::path output_source = output_dir / (base_filename + ".cpp");

    fs_utils::create_file_with_content(output_header, header_str);
    fs_utils::create_file_with_content(output_source, cpp_str);

    std::cout << "Generated files written to " << output_dir << std::endl;
}

bool is_system_header(const std::string &line) {
    std::string trimmed = trim(line);
    return trimmed.starts_with("#include <") && trimmed.ends_with(">");
}

bool is_local_header(const std::string &line) {
    std::string trimmed = trim(line);
    return trimmed.starts_with("#include \"") && trimmed.ends_with("\"");
}

std::vector<std::string> get_system_headers(const std::vector<std::string> &headers) {
    std::vector<std::string> system_headers;
    for (const auto &header : headers) {
        if (is_system_header(header)) {
            system_headers.push_back(trim(header));
        }
    }
    return system_headers;
}

MetaFunction generate_interactive_invoker(std::vector<meta_utils::MetaType> available_types) {
    // NOTE: one day I think we can remove the dep on available types
    MetaFunction interactive_invoker(R"(
void start_interactive_invoker(std::vector<meta_utils::MetaType> available_types) {
    std::cout << "Enter function invocation strings (type 'quit' to exit):\n";

    std::string input;
    while (true) {
        std::cout << "> ";
        std::getline(std::cin, input);

        if (input == "quit")
            break;

        std::optional<std::string> result = invoke(input, available_types);
        if (result.has_value()) {
            std::cout << "Result: " << result.value() << "\n";
        } else {
            std::cout << "Invocation failed.\n";
        }
    }

    std::cout << "Goodbye!\n";
})",
                                     create_type_name_to_meta_type_map(available_types));
    return interactive_invoker;
}

} // namespace meta_utils
