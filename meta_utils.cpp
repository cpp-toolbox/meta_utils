#include "meta_utils.hpp"
#include <filesystem>
#include <iostream>
#include <optional>
#include <vector>
#include <algorithm> // for std::remove_if

namespace meta_utils {

std::string create_local_include(const std::string &path) { return "#include \"" + path + "\""; };

MetaParameter::MetaParameter(const std::string &input) {

    // Match:
    // - leading whitespace
    // - greedy type match that includes optional &, *, &&, const at the end
    // - single space
    // - variable name (word characters)
    // - optional default assignment
    static const std::regex param_re(R"(^\s*(.+?[\s*&]+)\s*(\w+)(\s*=.*)?$)");

    std::smatch match;
    if (!std::regex_match(input, match, param_re)) {
        throw std::invalid_argument("Invalid MetaParameter input: expected format 'Type Name [= default]'. Got: " +
                                    input);
    }

    std::string raw_type_str = match[1];
    name = match[2];

    std::string cleaned_type_str = clean_type_string(raw_type_str);

    auto parsed_type = parse_meta_type_from_string(cleaned_type_str);
    if (!parsed_type.has_value()) {
        throw std::invalid_argument("Failed to parse MetaType from string: '" + cleaned_type_str + "'");
    }

    type = parsed_type.value();
}

// NOTE: this needs to get autogenerated
// the return type needs to be autogenerated as well...
std::vector<float> parse_vector_of_type(const std::string &input) {
    std::string trimmed = input;

    // Remove surrounding curly braces if present
    if (!trimmed.empty() && trimmed.front() == '{' && trimmed.back() == '}') {
        trimmed = trimmed.substr(1, trimmed.size() - 2);
    }

    std::vector<float> result;
    std::stringstream ss(trimmed);
    std::string element;

    while (std::getline(ss, element, ',')) {
        // Trim whitespace
        element.erase(std::remove_if(element.begin(), element.end(), ::isspace), element.end());

        if (!element.empty()) {
            try {
                auto conversion = [](std::string s) { return std::stof(s); };
                // NOTE: HERE we need to autogenerate this part to call the MetaTypes conversion function
                result.push_back(conversion(element));
            } catch (...) {
                // Invalid float, ignore or handle as needed
            }
        }
    }

    return result;
}

std::string create_string_to_vector_of_type_func(MetaType type_parameter) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::string &input) -> std::vector<", type_parameter.get_type_name(), "> {");
    msa.add("    std::string trimmed = input;");
    msa.add("    if (!trimmed.empty() && trimmed.front() == '{' && trimmed.back() == '}') {");
    msa.add("        trimmed = trimmed.substr(1, trimmed.size() - 2);");
    msa.add("    }");
    msa.add("");
    msa.add("    std::vector<", type_parameter.get_type_name(), "> result;");
    msa.add("    std::regex element_re(R\"(", type_parameter.literal_regex, ")\");");
    msa.add("    auto begin = std::sregex_iterator(trimmed.begin(), trimmed.end(), element_re);");
    msa.add("    auto end = std::sregex_iterator();");
    msa.add("");
    msa.add("    for (auto it = begin; it != end; ++it) {");
    msa.add("        try {");
    msa.add("            auto conversion = ", type_parameter.string_to_type_func, ";");
    msa.add("            result.push_back(conversion(it->str()));");
    msa.add("        } catch (...) {");
    msa.add("            // Ignore malformed elements");
    msa.add("        }");
    msa.add("    }");
    msa.add("    return result;");
    msa.add("}");

    return msa.str();
}

std::string create_vector_of_type_to_string_func(MetaType type_parameter) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::vector<", type_parameter.get_type_name(), ">& vec) -> std::string {");
    msa.add("    std::ostringstream oss;");
    msa.add("    oss << \"{\";");
    msa.add("    auto conversion = ", type_parameter.type_to_string_func, ";");
    msa.add("");
    msa.add("    for (size_t i = 0; i < vec.size(); ++i) {");
    msa.add("        oss << conversion(vec[i]);");
    msa.add("        if (i + 1 < vec.size())");
    msa.add("            oss << \", \";");
    msa.add("    }");
    msa.add("");
    msa.add("    oss << \"}\";");
    msa.add("    return oss.str();");
    msa.add("}");

    return msa.str();
}

// Extracts top-level comma-separated substrings from inside <...>
// e.g., split_template_args("int, std::vector<float>, std::map<int, double>")
//   â†’ ["int", "std::vector<float>", "std::map<int, double>"]
std::vector<std::string> split_template_args(const std::string &s) {
    std::vector<std::string> args;
    int depth = 0;
    std::string current;

    for (char c : s) {
        if (c == '<') {
            depth++;
            current += c;
        } else if (c == '>') {
            depth--;
            current += c;
        } else if (c == ',' && depth == 0) {
            args.push_back(text_utils::trim(current));
            current.clear();
        } else {
            current += c;
        }
    }

    if (!current.empty()) {
        args.push_back(text_utils::trim(current));
    }

    return args;
}

std::string trim(const std::string &s) {
    size_t start = s.find_first_not_of(" \t\n\r");
    if (start == std::string::npos)
        return "";
    size_t end = s.find_last_not_of(" \t\n\r");
    return s.substr(start, end - start + 1);
}

std::vector<std::string> split_args(const std::string &args_str) {
    std::vector<std::string> args;
    std::string current;
    int depth = 0;
    for (char c : args_str) {
        if (c == ',' && depth == 0) {
            args.push_back(trim(current));
            current.clear();
        } else {
            if (c == '<' || c == '(')
                depth++;
            else if (c == '>' || c == ')')
                depth--;
            current += c;
        }
    }
    if (!current.empty())
        args.push_back(trim(current));
    return args;
}

std::string simplify_parameter(const std::string &param_str) {
    std::string s = param_str;

    // Remove default value
    auto eq_pos = s.find('=');
    if (eq_pos != std::string::npos)
        s = s.substr(0, eq_pos);

    // Trim
    auto trim = [](std::string &str) {
        str.erase(str.begin(),
                  std::find_if(str.begin(), str.end(), [](unsigned char ch) { return !std::isspace(ch); }));
        str.erase(std::find_if(str.rbegin(), str.rend(), [](unsigned char ch) { return !std::isspace(ch); }).base(),
                  str.end());
    };
    trim(s);

    // Remove leading "const "
    if (s.rfind("const ", 0) == 0)
        s = s.substr(6);

    // Tokenize
    std::istringstream iss(s);
    std::vector<std::string> tokens;
    std::string token;
    while (iss >> token)
        tokens.push_back(token);

    if (tokens.size() < 1)
        throw std::runtime_error("Invalid parameter: " + param_str);

    // Get the name token
    std::string name = tokens.back();
    tokens.pop_back();

    // If name is prefixed with & or *, put that back into the type
    std::string symbol_prefix;
    while (!name.empty() && (name[0] == '&' || name[0] == '*')) {
        symbol_prefix += name[0];
        name = name.substr(1);
    }

    // Reconstruct type
    std::string type;
    for (const auto &t : tokens)
        type += (type.empty() ? "" : " ") + t;

    type += symbol_prefix;

    // Remove all & and * from type
    type.erase(std::remove_if(type.begin(), type.end(), [](char c) { return c == '&' || c == '*'; }), type.end());

    trim(type);
    return type + " " + name;
}

std::string generate_regex_to_match_valid_invocation_of_func(const std::string &signature) {

    std::string return_type, func_name, args_str;

    std::regex re(regex_utils::function_signature_ree);
    std::smatch match;
    if (!std::regex_match(signature, match, re)) {

        std::regex re(regex_utils::constructor_signature_re);
        if (!std::regex_match(signature, match, re)) {

            throw std::invalid_argument("Invalid function or constructor signature");
        } else { // we have a constructor

            return_type = match[1];
            func_name = match[1];
            args_str = match[2];
        }
    } else {
        return_type = text_utils::trim(match[1]);
        func_name = match[3];
        args_str = match[4];
    }

    auto args = split_args(args_str);

    std::vector<std::string> arg_types;

    static const std::regex param_re(R"(^\s*(.+?)\s+(\w+)(\s*=.*)?$)");

    for (auto &arg : args) {
        if (arg.empty())
            continue;

        arg = simplify_parameter(arg);

        std::smatch match;
        if (!std::regex_match(arg, match, param_re)) {
            throw std::invalid_argument("Each argument must match format: 'Type Name [= default]'. Got: " + arg);
        }

        std::string raw_type_str = match[1];
        std::string name = match[2];
        // std::string default_value = match[3]; // (optional) if needed later

        std::string cleaned_type_str = clean_type_string(raw_type_str);

        arg_types.push_back(cleaned_type_str);
    }

    // Build regex pattern for argument parsing
    std::vector<std::string> argument_literal_regexes;

    for (const auto &typ : arg_types) {
        auto mt = meta_utils::parse_meta_type_from_string(typ).value();
        argument_literal_regexes.push_back(regex_utils::capture(mt.literal_regex));
    }

    std::string function_invocation_regex = text_utils::join(
        {regex_utils::start_of_line, func_name, "\\(",
         text_utils::join(argument_literal_regexes, regex_utils::optional_ws + "," + regex_utils::optional_ws), "\\)",
         regex_utils::end_of_line},
        regex_utils::optional_ws);

    return function_invocation_regex;
}

// NOTE: this is an important function
std::optional<MetaType> parse_meta_type_from_string(const std::string &type_str) {

    // NOTE: using meta types here. so meta types must be defined first. REALLY BAD...
    auto concrete_type_name_to_meta_type = meta_types.get_concrete_type_name_to_meta_type();

    std::string s = clean_type_string(type_str);

    if (auto it = concrete_type_name_to_meta_type.find(s); it != concrete_type_name_to_meta_type.end()) {
        return it->second;
    } // now we know that the type is a generic type

    std::cout << type_str << " is not a concrete type" << std::endl;

    // try to match template type: base<...>
    static const std::regex template_regex(R"((\w+(?:::\w+)*)\s*<\s*([^<>]+(?:<[^<>]+>[^<>]*)*)\s*>)");
    std::smatch match;
    if (std::regex_match(s, match, template_regex)) {

        std::string base_type = match[1].str(); // e.g., "std::vector"
        std::string args_str = match[2].str();  // e.g., "int" or "std::string, std::vector<int>"

        std::cout << "base_type: " << base_type << std::endl;
        std::cout << "args_str: " << args_str << std::endl;

        // parse argument types recursively
        std::vector<std::string> inner_type_strs = split_template_args(args_str);
        std::vector<MetaType> inner_types;

        for (const std::string &arg_str : inner_type_strs) {

            auto maybe_inner = parse_meta_type_from_string(arg_str);

            if (!maybe_inner)
                return std::nullopt; // fail if any inner type is unknown
            inner_types.push_back(*maybe_inner);
        }

        // NOTE: only having support for vector right now.
        MetaType mt = meta_utils::generic_type_to_metatype_constructor.at(base_type)(inner_types.at(0));

        return mt;
    } else {
        std::cout << "regex didn't match : " << type_str << std::endl;
    }

    return std::nullopt;
}

std::string clean_type_string(const std::string &raw_type) {
    std::string s = raw_type;

    // Remove 'const', 'volatile', '&', '*'
    static const std::regex modifiers(R"(\bconst\b|\bvolatile\b|&|\*)");
    s = std::regex_replace(s, modifiers, "");

    // Remove extra whitespace
    static const std::regex extra_spaces(R"(\s+)");
    s = std::regex_replace(s, extra_spaces, " ");

    // Trim leading/trailing space
    if (!s.empty() && s.front() == ' ')
        s.erase(s.begin());
    if (!s.empty() && s.back() == ' ')
        s.pop_back();

    return s;
}

std::string generate_string_invoker_for_function_with_string_return_type(const MetaFunctionSignature &sig) {
    const std::string &return_type = sig.return_type;
    const std::string &func_name = sig.name;

    // Find the type_to_string_func for the return type (except void)
    std::string return_type_to_string_func;
    if (return_type != "void" && return_type != "std::string") {
        auto meta_type_opt = meta_utils::parse_meta_type_from_string(return_type);
        if (!meta_type_opt) {
            throw std::runtime_error("Unknown return type: " + return_type);
        }
        return_type_to_string_func = meta_type_opt.value().type_to_string_func;
    }

    // Compose the new function name
    std::string new_func_name = func_name + "_string_invoker_to_string";

    text_utils::MultilineStringAccumulator msa;

    msa.add("std::optional<std::string> ", new_func_name, "(const std::string &input) {");
    msa.add("    auto opt_result = ", func_name, "_string_invoker(input);");
    msa.add("    if (!opt_result) return std::nullopt;");

    if (return_type == "void") {
        msa.add("    return std::string(); // void returns empty string");
    } else if (return_type == "std::string") {
        msa.add("    return *opt_result;");
    } else {
        msa.add("    auto conversion = ", return_type_to_string_func, ";");
        msa.add("    return conversion(*opt_result);");
    }

    msa.add("}");

    return msa.str();
}

std::string generate_string_invoker_for_function(const MetaFunctionSignature &sig, const std ::string &func_postfix) {
    const auto &params = sig.parameters;

    std::vector<std::string> lambda_conversions;
    std::vector<std::string> arg_to_var_conversions;
    std::vector<std::string> call_to_actual_func_args;

    for (size_t i = 0; i < params.size(); i++) {
        const auto &param = params[i];
        const std::string &typ = param.type.get_type_name();
        const std::string &name = param.name;
        int group_num = static_cast<int>(i + 1);

        const std::string &string_to_type_func = param.type.string_to_type_func;

        std::string conversion_func_name = "conversion" + std::to_string(group_num);
        lambda_conversions.push_back("    auto " + conversion_func_name + " = " + string_to_type_func + ";");

        // TODO: in the future we don't want to return optionals I believe, also this is a bad way of doing it
        bool returns_optional = text_utils::contains(string_to_type_func, "std::optional");

        std::string variable_assignment = "    " + typ + " " + name + " = " + conversion_func_name + "(match[" +
                                          std::to_string(group_num) + "])" + (returns_optional ? ".value()" : "") + ";";

        arg_to_var_conversions.push_back(variable_assignment);
        call_to_actual_func_args.push_back(name);
    }

    std::string function_invocation_regex = sig.invocation_regex;

    text_utils::MultilineStringAccumulator msa;

    // NOTE: we use the camel case because sometimes we operate on constructors which are in camel case
    msa.add("std::optional<", sig.return_type, "> ", text_utils::pascal_to_snake_case(sig.name), func_postfix,
            "(const std::string &invocation) {");
    msa.add("    std::regex re(R\"(", function_invocation_regex, ")\");");
    msa.add("    std::smatch match;");
    msa.add("    if (!std::regex_match(invocation, match, re)) return std::nullopt;");
    msa.add("");

    for (size_t i = 0; i < arg_to_var_conversions.size(); ++i) {
        msa.add(lambda_conversions[i]);
        msa.add(arg_to_var_conversions[i]);
    }

    msa.add("");

    // call actual function
    msa.add("    ", sig.return_type, " result = ", get_fully_qualified_name(sig), "(",
            text_utils::join(call_to_actual_func_args, ", "), ");");
    msa.add("    return result;");

    msa.add("}");
    return msa.str();
}

// Helper join function for vector<string>
std::string join(const std::vector<std::string> &v, const std::string &sep) {
    std::string res;
    for (size_t i = 0; i < v.size(); i++) {
        res += v[i];
        if (i + 1 < v.size())
            res += sep;
    }
    return res;
}

// TODO: the below two functions are simply mappings, create a generic map function in collection utils one day
std::vector<MetaFunction> generate_string_invokers_to_string(std::vector<MetaFunction> mfs) {

    std::vector<MetaFunction> new_mfs;
    for (const auto &mf : mfs) {
        auto invoker_str_return_str =
            meta_utils::generate_string_invoker_for_function_with_string_return_type(mf.signature);
        meta_utils::MetaFunction invoker_return_string(invoker_str_return_str);
        new_mfs.push_back(invoker_str_return_str);
    }

    return new_mfs;
}

std::vector<MetaVariable> generate_meta_function_signature_variables(std::vector<MetaFunction> meta_functions) {
    std::vector<MetaVariable> mf_vars;
    for (const auto &mf : meta_functions) {
        auto var_name = "mfs_" + mf.signature.name;
        // NOTE: we're using value as the parameters which is weird but it works.
        auto value = text_utils::join({text_utils::surround(mf.signature.to_string(), text_utils::double_quote),
                                       text_utils::surround(mf.name_space, text_utils::double_quote)},
                                      ", ");

        std::cout << "name place: " << mf.name_space << std::endl;
        MetaVariable mv("meta_utils::MetaFunctionSignature", var_name, value, MetaVariable::InitStyle::Definition,
                        mf.name_space);
        mf_vars.push_back(mv);
    }
    return mf_vars;
}

std::vector<MetaFunction> generate_string_invokers(std::vector<MetaFunction> mfs) {

    std::vector<MetaFunction> new_mfs;
    for (const auto &mf : mfs) {
        auto invoker_str = meta_utils::generate_string_invoker_for_function(mf.signature);
        meta_utils::MetaFunction invoker(invoker_str);
        new_mfs.push_back(invoker);
    }

    return new_mfs;
}

std::vector<std::string> generate_type_grouped_invokers(const std::vector<meta_utils::MetaFunction> &string_invokers) {
    std::unordered_map<std::string, std::vector<meta_utils::MetaFunction>> return_type_to_funcs;

    for (const auto &si : string_invokers) {
        return_type_to_funcs[si.signature.return_type].push_back(si);
    }

    std::vector<std::string> type_grouped_invokers;
    for (const auto &[return_type, funcs] : return_type_to_funcs) {
        type_grouped_invokers.push_back(
            generate_string_invoker_for_function_collection(funcs, return_type, "_string_invoker"));
    }

    return type_grouped_invokers;
}

std::string sanitize_type(const std::string &type_str) {
    std::string fixed;
    fixed = text_utils::replace_substring(type_str, "::", "_");
    fixed = text_utils::replace_substring(fixed, "<", "_");
    fixed = text_utils::replace_substring(fixed, ">", "");
    return fixed;
}

// we operate under the assumption that every function in the collection has the same return type.
std::string generate_string_invoker_for_function_collection(std::vector<MetaFunction> mfs_with_same_return_type,
                                                            std::string return_type, std::string func_postfix) {
    std::ostringstream oss;

    oss << "std::optional<" << return_type << "> invoker_that_returns_" << sanitize_type(return_type)
        << "(const std::string &invocation) "
           "{\n\n";

    // Generate if-else chain for invocation matching
    for (const auto &func : mfs_with_same_return_type) {
        oss << "    if (std::regex_match(invocation, std::regex(mfs_" << func.signature.name
            << ".invocation_regex))) {\n";
        oss << "        return " << func.signature.name << func_postfix << "(invocation);\n";
        oss << "    }\n";
    }

    oss << "\n    return std::nullopt;\n";
    oss << "}\n";

    return oss.str();
}

MetaFunction create_interactive_invoker() {
    text_utils::MultilineStringAccumulator msa;

    msa.add("void start_interactive_invoker() {");

    msa.add("std::map<std::string, meta_utils::MetaFunctionSignature> options_dict;");
    // TODO: fix hardcode here
    msa.add("    for (size_t i = 0; i < meta_text_utils.all_meta_function_signatures.size(); ++i) {");
    msa.add("    options_dict[std::to_string(i + 1)] = meta_text_utils.all_meta_function_signatures[i];");
    msa.add("}");

    msa.add("if (options_dict.empty()) {");
    msa.add("    std::cout << \"No functions available.\" << std::endl;");
    msa.add("    return; // nothing to do");
    msa.add("}");

    msa.add("std::vector<std::pair<std::string, meta_utils::MetaFunctionSignature>> "
            "sorted_options(options_dict.begin(), options_dict.end());");

    msa.add("std::sort(sorted_options.begin(), sorted_options.end(), [](const auto &a, const auto &b) { return "
            "std::stoi(a.first) < std::stoi(b.first); });");

    msa.add("bool keep_running = true;");

    msa.add("while (keep_running) {");
    msa.add("    std::cout << \"Select a function to invoke:\" << std::endl;;");
    msa.add("    for (const auto &[key, func] : sorted_options) {");
    msa.add("        std::cout << key << \". \" << func.to_string() << std::endl;");
    msa.add("    }");

    msa.add("    std::cout << \"q. Quit\" << std::endl;");

    msa.add("    std::string choice = get_validated_input( []() {");
    msa.add("        std::cout << \"Enter choice: \";");
    msa.add("        std::string s;");
    msa.add("        std::getline(std::cin, s);");
    msa.add("        return text_utils::trim(s);");
    msa.add("    },");
    msa.add("    [&](const std::string &input) { return input == \"q\" || options_dict.find(input) != "
            "options_dict.end(); }, \"Invalid choice. Please try again.\");");

    msa.add("    if (choice == \"q\") {");
    msa.add("        std::cout << \"Goodbye.\" << std::endl;");
    msa.add("        break;");
    msa.add("}");

    msa.add("    meta_utils::MetaFunctionSignature selected = options_dict[choice];");

    msa.add("    std::vector<std::string> args;");
    msa.add("    for (const auto &param : selected.parameters) {");
    msa.add("        std::string val = get_input_with_default(\"Enter value for \" + param.name + \" (\" + "
            "param.type.get_type_name() + \")\", \"0\");");
    msa.add("        args.push_back(val);");
    msa.add("    }");

    msa.add("    std::string invocation = selected.name + \"(\";");
    msa.add("    for (size_t i = 0; i < args.size(); ++i) {");
    msa.add("        invocation += args[i];");
    msa.add("        if (i < args.size() - 1) {");
    msa.add("            invocation += \", \";");
    msa.add("        }");
    msa.add("    }");
    msa.add("    invocation += \")\";");

    msa.add("    auto result = invoker_that_returns_std_string(invocation);");
    msa.add("    if (result.has_value()) {");
    msa.add("        std::cout << \"Result: \" << result.value() << std::endl;");
    msa.add("    } else {");
    msa.add("        std::cout << \"Invocation failed.\" << std::endl;");
    msa.add("    }");

    msa.add("    std::string run_again = get_validated_input(");
    msa.add("    []() {");
    msa.add("        std::cout << \"Do you want to run another function? (y/n): \";");
    msa.add("        std::string s;");
    msa.add("        std::getline(std::cin, s);");
    msa.add("        return text_utils::trim(s);");
    msa.add("    },");
    msa.add("    [](const std::string &input) { return input == \"y\" || input == \"n\"; }, \"Please enter 'y' or "
            "'n'.\");");

    msa.add("    if (run_again == \"n\") {");
    msa.add("        keep_running = false;");
    msa.add("        std::cout << \"Goodbye.\" << std::endl;");
    msa.add("    }");

    msa.add("}");
    msa.add("}");

    MetaFunction mf(msa.str());

    return mf;
}

void generate_string_invokers_program_wide(std::vector<StringInvokerGenerationSettingsForHeaderSource> settings) {

    auto output_header_path = "src/meta_program/meta_program.hpp";
    auto output_source_path = "src/meta_program/meta_program.cpp";

    std::filesystem::path output_header_dir = std::filesystem::path(output_header_path).parent_path();

    // TODO: get rid of this
    struct ObjectFunction {
        std::string object_name;
        MetaFunction function;
    };
    std::unordered_map<std::string, std::vector<ObjectFunction>> return_type_to_invokers_that_return_it;

    std::vector<std::string> header_paths_of_other_string_invokers;

    std::vector<MetaCodeCollection> generated_mccs;

    for (const auto &setting : settings) {
        std::string invoker_path = fs_utils::get_containing_directory(setting.header_file_path) + "/meta/" +
                                   fs_utils::get_filename_from_path(setting.header_file_path);
        std::string rel_path = fs_utils::get_relative_path(output_header_dir, invoker_path);
        auto rel_include = "#include \"" + rel_path + "\"";
        header_paths_of_other_string_invokers.push_back(rel_include);
        MetaCodeCollection mfc = generate_string_invokers_from_header_and_source(setting);
        generated_mccs.push_back(mfc);
        // WARN: huge assumption here.
        MetaClass mc = mfc.classes.at(0);
        for (const auto &meth : mc.methods) {
            auto fun = meth.function;
            bool is_string_to_type_invoker = text_utils::starts_with(fun.signature.name, "invoker_that_returns");
            // WARN: this is a sketchy way of extracting the type with assumptions
            std::string return_type = text_utils::replace_substring(fun.signature.name, "invoker_that_returns", "");
            if (is_string_to_type_invoker) {
                return_type_to_invokers_that_return_it[return_type].push_back(
                    {text_utils::pascal_to_snake_case(mc.name), fun});
            }
        }
    }

    // NOTE: now we want to collect all the functions that we can call, which is given by the input collection
    std::vector<MetaVariable> all_meta_function_signatures_from_sub_string_invokers =
        collection_utils::join_all_vectors(
            collection_utils::map_vector(generated_mccs, [](MetaCodeCollection mfc) { return mfc.variables; }));

    MetaCodeCollection top_level_invoker_mfc;
    top_level_invoker_mfc.name = "meta_program";
    top_level_invoker_mfc.name_space = "meta_program";

    // top_level_invoker_mfc.variables.push_back(vector_of_meta_function_signature_var_names);

    // NOTE: one day I want to automate includes, mfs don't need includes individual functions have includes required
    // for declaration and definition and we pull from there
    top_level_invoker_mfc.includes_required_for_declaration = header_paths_of_other_string_invokers;
    top_level_invoker_mfc.includes_required_for_declaration.push_back(optional_include);
    top_level_invoker_mfc.includes_required_for_declaration.push_back(
        create_local_include(fs_utils::get_relative_path(output_header_dir, "src/utility/meta_utils/meta_utils.hpp")));
    top_level_invoker_mfc.includes_required_for_definition.push_back("#include \"meta_program.hpp\"");

    top_level_invoker_mfc.includes_required_for_declaration.push_back(
        create_local_include(fs_utils::get_relative_path(output_header_dir, "src/utility/user_input/user_input.hpp")));

    meta_utils::MetaClass meta_class("MetaProgram");

    for (const auto &[return_type, object_functions] : return_type_to_invokers_that_return_it) {
        std::cout << "got in here epic" << std::endl;
        text_utils::MultilineStringAccumulator mla;
        if (object_functions.empty())
            continue;

        // NOTE: this pattern checks to see if empty, if empty then don't do anything, if
        // none empty then declare it v
        auto object_function = object_functions.at(0);
        MetaFunction mf = object_function.function;
        mla.add(mf.signature.return_type, " val;");

        // NOTE: then optionally try and run each possible one sequentially.
        for (const auto &object_function : object_functions) {
            auto mf = object_function.function;
            mla.add("val = ", object_function.object_name + ".", mf.signature.name, "(invocation);");
            mla.add("if (val)");
            mla.add("    return val;");
            mla.add("");
        }
        mla.add("return std::nullopt;");
        MetaFunction top_level_mf(mf.signature, mla, "");
        meta_class.add_method(MetaMethod(top_level_mf));
        // top_level_invoker_mfc.add_function();
    }

    meta_class.add_method(MetaMethod(create_interactive_invoker()));

    MetaParameter vector_of_meta_types("std::vector<meta_utils::MetaType> concrete_types");
    MetaConstructor mc(meta_class.name, {vector_of_meta_types}, "", AccessSpecifier::Public,
                       {"concrete_types(concrete_types)"});
    meta_class.constructors.push_back(mc);

    MetaVariable concrete_types("std::vector<meta_utils::MetaType> ", "concrete_types", "");
    MetaAttribute concrete_types_reference(concrete_types, AccessSpecifier::Public);
    meta_class.add_attribute(concrete_types_reference);

    for (const auto &mcc : generated_mccs) {
        // NOTE: we use the assumption that each generated mccs has exactly one class right now, which is a bit sketchy
        MetaClass mc = mcc.classes.at(0);

        std::string var_name;
        if (not mcc.name_space.empty()) {
            var_name = mcc.name_space + "::" + mc.name;
        } else {
            var_name = mc.name;
        }

        MetaVariable mv(var_name, text_utils::pascal_to_snake_case(mc.name), "concrete_types",
                        MetaVariable::InitStyle::Brace);
        MetaAttribute ma(mv, AccessSpecifier::Public);
        meta_class.add_attribute(ma);
    }

    top_level_invoker_mfc.classes.push_back(meta_class);

    top_level_invoker_mfc.write_to_header_and_source(output_header_path, output_source_path);
}

MetaCodeCollection
generate_string_invokers_from_header_and_source(const StringInvokerGenerationSettingsForHeaderSource &sigsfhs) {
    return generate_string_invokers_from_header_and_source(
        sigsfhs.header_file_path, sigsfhs.source_file_path, sigsfhs.create_top_level_invoker,
        sigsfhs.create_type_grouped_invokers, sigsfhs.string_signatures_for_potential_filtering, sigsfhs.mode);
}

MetaCodeCollection generate_string_invokers_from_header_and_source(
    const std::string &input_header_path, const std::string &input_source_path, bool create_top_level_invoker,
    bool create_type_grouped_invokers, const std::vector<std::string> &string_signatures, FilterMode mode) {

    const std::string output_name_prefix = "meta_";

    meta_utils::MetaCodeCollection input_collection(input_header_path, input_source_path, string_signatures, mode);

    meta_utils::MetaCodeCollection output_collection;

    bool input_collection_doesnt_use_namespace = input_collection.name_space == "";
    output_collection.name_space =
        output_name_prefix +
        (input_collection_doesnt_use_namespace ? input_collection.name : input_collection.name_space);
    output_collection.name = output_name_prefix + input_collection.name;

    auto class_name = text_utils::snake_to_pascal_case(output_name_prefix + input_collection.name);
    meta_utils::MetaClass meta_class(class_name);
    MetaParameter vector_of_meta_types("std::vector<meta_utils::MetaType> &concrete_types");
    MetaConstructor mc(class_name, {vector_of_meta_types}, "", AccessSpecifier::Public,
                       {"concrete_types(concrete_types)"});
    meta_class.constructors.push_back(mc);

    MetaVariable concrete_types("std::vector<meta_utils::MetaType> &", "concrete_types", "");
    MetaAttribute concrete_types_reference(concrete_types, AccessSpecifier::Public);
    meta_class.add_attribute(concrete_types_reference);

    output_collection.includes_required_for_declaration =
        get_system_headers(input_collection.includes_required_for_declaration);

    output_collection.includes_required_for_declaration.push_back(meta_utils::string_include);
    output_collection.includes_required_for_declaration.push_back(meta_utils::optional_include);

    std::filesystem::path input_header_dir = std::filesystem::path(input_header_path).parent_path();
    std::filesystem::path output_dir = input_header_dir / "meta";

    auto meta_utils_rel_path = fs_utils::get_relative_path(output_dir, "src/utility/meta_utils/meta_utils.hpp");

    auto rel_glm_utils_path = fs_utils::get_relative_path(output_dir, "src/utility/glm_utils/glm_utils.hpp");
    auto rel_glm_printing_path = fs_utils::get_relative_path(output_dir, "src/utility/glm_printing/glm_printing.hpp");

    output_collection.includes_required_for_declaration = {
        create_local_include(meta_utils_rel_path),
        "#include \"../" + std::filesystem::path(input_header_path).filename().string() + "\"",
        // "#include \"" + std::string(rel_glm_utils_path) + "\"",
        // "#include \"" + std::string(rel_glm_printing_path) + "\"",
        meta_utils::regex_include, meta_utils::optional_include};

    // output_collection.includes_required_for_definition = {
    //     "#include \"" + std::filesystem::path(input_header_path).filename().string() + "\"",
    //     "#include \"../" + std::filesystem::path(input_header_path).filename().string() + "\"",
    //     meta_utils::regex_include};

    auto string_invokers = generate_string_invokers(input_collection.functions);

    auto meta_function_signature_variables = generate_meta_function_signature_variables(input_collection.functions);
    collection_utils::for_each_in_vector(meta_function_signature_variables, [&](MetaVariable &mv) {
        mv.name_space = output_collection.name_space;
        mv.init_style = MetaVariable::InitStyle::Brace;
    });
    collection_utils::for_each_in_vector(meta_function_signature_variables, [&](MetaVariable &mv) {
        meta_class.add_attribute(MetaAttribute(mv, AccessSpecifier::Public));
    });

    MetaVariable all_meta_function_signatures_vector(
        "std::vector<meta_utils::MetaFunctionSignature>", "all_meta_function_signatures",
        text_utils::surround(text_utils::join(collection_utils::map_vector(meta_function_signature_variables,
                                                                           [](MetaVariable mv) { return mv.name; }),
                                              ", "),
                             text_utils::left_brace, text_utils::right_brace),
        MetaVariable::InitStyle::Assignment);

    meta_class.add_attribute(MetaAttribute(all_meta_function_signatures_vector, AccessSpecifier::Public));

    // output_collection.variables = generate_meta_function_signature_variables(input_collection.functions);

    if (create_type_grouped_invokers) {
        auto type_grouped_invokers = generate_type_grouped_invokers(input_collection.functions);
        for (const auto &type_grouped_invoker : type_grouped_invokers) {
            meta_utils::MetaFunction full_invoker(type_grouped_invoker, output_collection.name_space);
            meta_utils::MetaMethod method(full_invoker);
            // output_collection.add_function(full_invoker);
            meta_class.add_method(method);
        }
    }

    auto all_needed_functions = string_invokers;

    // we also need ones that return optional strings.
    if (create_top_level_invoker) {
        auto string_invoker_to_strings = generate_string_invokers_to_string(input_collection.functions);
        for (const auto inv : string_invoker_to_strings) {
            all_needed_functions.push_back(inv);
        }

        auto full_invoker_str = meta_utils::generate_string_invoker_for_function_collection(
            input_collection.functions, "std::string", "_string_invoker_to_string");
        meta_utils::MetaFunction full_invoker(full_invoker_str, output_collection.name_space);
        meta_class.add_method(MetaMethod(full_invoker));
        meta_class.add_method(MetaMethod(generate_interactive_invoker()));
        // output_collection.add_function(full_invoker);
        // output_collection.add_function(generate_interactive_invoker());
    }

    for (const auto &si : all_needed_functions) {
        std::cout << "adding: " << si.signature.to_string() << std::endl;
        meta_class.add_method(MetaMethod(si));
        // output_collection.add_function(si);
    }

    std::string base_filename = std::filesystem::path(input_header_path).stem().string();
    std::filesystem::path output_header = output_dir / (base_filename + ".hpp");
    std::filesystem::path output_source = output_dir / (base_filename + ".cpp");

    output_collection.classes.push_back(meta_class);
    output_collection.write_to_header_and_source(output_header, output_source);

    std::cout << "Generated files written to " << output_dir << std::endl;

    return output_collection;
}

bool is_system_header(const std::string &line) {
    std::string trimmed = trim(line);
    return trimmed.starts_with("#include <") && trimmed.ends_with(">");
}

bool is_local_header(const std::string &line) {
    std::string trimmed = trim(line);
    return trimmed.starts_with("#include \"") && trimmed.ends_with("\"");
}

std::vector<std::string> get_system_headers(const std::vector<std::string> &headers) {
    std::vector<std::string> system_headers;
    for (const auto &header : headers) {
        if (is_system_header(header)) {
            system_headers.push_back(trim(header));
        }
    }
    return system_headers;
}

MetaFunction generate_interactive_invoker() {
    // NOTE: one day I think we can remove the dep on available types
    MetaFunction interactive_invoker(R"(
void start_interactive_invoker() {
    std::cout << "Enter function invocation strings (type 'quit' to exit):\n";

    std::string input;
    while (true) {
        std::cout << "> ";
        std::getline(std::cin, input);

        if (input == "quit")
            break;

        std::optional<std::string> result = invoker_that_returns_std_string(input);
        if (result.has_value()) {
            std::cout << "Result: " << result.value() << "\n";
        } else {
            std::cout << "Invocation failed.\n";
        }
    }

    std::cout << "Goodbye!\n";
})");
    return interactive_invoker;
}

} // namespace meta_utils
