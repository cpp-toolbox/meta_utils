#include "meta_utils.hpp"
#include <filesystem>
#include <iostream>
#include <optional>
#include <tuple>
#include <vector>
#include <algorithm> // for std::remove_if

namespace meta_utils {

std::string create_local_include(const std::string &path) { return "#include \"" + path + "\""; };

MetaParameter::MetaParameter(const std::string &input) {

    // Match:
    // - leading whitespace
    // - greedy type match that includes optional &, *, &&, const at the end
    // - single space
    // - variable name (word characters)
    // - optional default assignment

    // NOTE: in the future we will do away with this regex
    static const std::regex param_re(R"(^\s*(.+?)\s+([*&]*\w+)(\s*=.*)?$)");

    std::smatch match;
    if (!std::regex_match(input, match, param_re)) {
        throw std::invalid_argument("Invalid MetaParameter input: expected format 'Type Name [= default]'. Got: " +
                                    input);
    }

    std::string raw_type_str = match[1];
    name = match[2];

    std::string cleaned_type_str = clean_type_string(raw_type_str);

    type = resolve_meta_type(cleaned_type_str);
}

// NOTE: this needs to get autogenerated
// the return type needs to be autogenerated as well...
std::vector<float> parse_vector_of_type(const std::string &input) {
    std::string trimmed = input;

    // Remove surrounding curly braces if present
    if (!trimmed.empty() && trimmed.front() == '{' && trimmed.back() == '}') {
        trimmed = trimmed.substr(1, trimmed.size() - 2);
    }

    std::vector<float> result;
    std::stringstream ss(trimmed);
    std::string element;

    while (std::getline(ss, element, ',')) {
        // Trim whitespace
        element.erase(std::remove_if(element.begin(), element.end(), ::isspace), element.end());

        if (!element.empty()) {
            try {
                auto conversion = [](std::string s) { return std::stof(s); };
                // NOTE: HERE we need to autogenerate this part to call the MetaTypes conversion function
                result.push_back(conversion(element));
            } catch (...) {
                // Invalid float, ignore or handle as needed
            }
        }
    }

    return result;
}

std::string create_string_to_vector_of_type_func(MetaType type_parameter) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::string &input) -> std::vector<", type_parameter.get_type_name(), "> {");
    msa.add("    std::string trimmed = input;");
    msa.add("    if (!trimmed.empty() && trimmed.front() == '{' && trimmed.back() == '}') {");
    msa.add("        trimmed = trimmed.substr(1, trimmed.size() - 2);");
    msa.add("    }");
    msa.add("");
    msa.add("    std::vector<", type_parameter.get_type_name(), "> result;");
    msa.add("    std::regex element_re(R\"(", type_parameter.literal_regex, ")\");");
    msa.add("    auto begin = std::sregex_iterator(trimmed.begin(), trimmed.end(), element_re);");
    msa.add("    auto end = std::sregex_iterator();");
    msa.add("");
    msa.add("    for (auto it = begin; it != end; ++it) {");
    msa.add("        try {");
    msa.add("            auto conversion = ", type_parameter.string_to_type_func_lambda, ";");
    msa.add("            result.push_back(conversion(it->str()));");
    msa.add("        } catch (...) {");
    msa.add("            // Ignore malformed elements");
    msa.add("        }");
    msa.add("    }");
    msa.add("    return result;");
    msa.add("}");

    return msa.str();
}

std::string create_vector_of_type_to_string_func(MetaType type_parameter) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::vector<", type_parameter.get_type_name(), ">& vec) -> std::string {");
    msa.add("    std::ostringstream oss;");
    msa.add("    oss << \"{\";");
    msa.add("    auto conversion = ", type_parameter.type_to_string_func_lambda, ";");
    msa.add("");
    msa.add("    for (size_t i = 0; i < vec.size(); ++i) {");
    msa.add("        oss << conversion(vec[i]);");
    msa.add("        if (i + 1 < vec.size())");
    msa.add("            oss << \", \";");
    msa.add("    }");
    msa.add("");
    msa.add("    oss << \"}\";");
    msa.add("    return oss.str();");
    msa.add("}");

    return msa.str();
}

std::string create_vector_of_type_serialize_func(MetaType type_parameter) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::vector<", type_parameter.get_type_name(), ">& vec) -> std::vector<uint8_t> {");
    msa.add("    std::vector<uint8_t> buffer;");

    // store vector size first
    msa.add("    size_t count = vec.size();");
    msa.add("    buffer.resize(sizeof(size_t));");
    msa.add("    std::memcpy(buffer.data(), &count, sizeof(size_t));");

    msa.add("");
    msa.add("    auto element_serializer = ", type_parameter.serialize_type_func_lambda, ";");

    if (type_parameter.variably_sized) {
        // variable-size inner type
        msa.add("    for (const auto& elem : vec) {");
        msa.add("        auto elem_bytes = element_serializer(elem);");
        msa.add("        size_t elem_size = elem_bytes.size();");
        msa.add("        buffer.resize(buffer.size() + sizeof(size_t));");
        msa.add("        std::memcpy(buffer.data() + buffer.size() - sizeof(size_t), &elem_size, sizeof(size_t));");
        msa.add("        buffer.insert(buffer.end(), elem_bytes.begin(), elem_bytes.end());");
        msa.add("    }");
    } else {
        // fixed-size inner type
        msa.add("    if (!vec.empty()) {");
        msa.add("        size_t elem_size = sizeof(", type_parameter.get_type_name(), ");");
        msa.add("        buffer.resize(buffer.size() + vec.size() * elem_size);");
        msa.add("        std::memcpy(buffer.data() + sizeof(size_t), vec.data(), vec.size() * elem_size);");
        msa.add("    }");
    }

    msa.add("    return buffer;");
    msa.add("}");

    return msa.str();
}

std::string create_vector_of_type_serialized_size_func(MetaType type_parameter) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::vector<", type_parameter.get_type_name(), ">& vec) -> size_t {");
    msa.add("    size_t total_size = sizeof(size_t); // space for storing count");

    auto element_size_lambda = type_parameter.size_when_serialized_bytes_func_lambda;

    if (type_parameter.variably_sized) {
        msa.add("    auto element_size_func = ", element_size_lambda, ";");
        msa.add("    for (const auto& elem : vec) {");
        msa.add("        size_t elem_size = element_size_func(elem);");
        msa.add("        total_size += sizeof(size_t) + elem_size; // size prefix + data");
        msa.add("    }");
    } else {
        msa.add("    if (!vec.empty()) {");
        msa.add("        total_size += vec.size() * ", element_size_lambda, "(vec[0]);");
        msa.add("    }");
    }

    msa.add("    return total_size;");
    msa.add("}");

    return msa.str();
}

std::string create_vector_of_type_deserialize_func(MetaType type_parameter) {
    text_utils::MultilineStringAccumulator msa;

    const std::string &inner = type_parameter.get_type_name();

    msa.add("[=](const std::vector<uint8_t>& buffer) -> std::vector<", inner, "> {");
    msa.add("    std::vector<", inner, "> result;");
    msa.add("    if (buffer.size() < sizeof(size_t)) return result;");

    // read count
    msa.add("    size_t count;");
    msa.add("    std::memcpy(&count, buffer.data(), sizeof(size_t));");

    msa.add("");
    msa.add("    size_t offset = sizeof(size_t);");
    msa.add("    auto element_deserializer = ", type_parameter.deserialize_type_func_lambda, ";");

    if (type_parameter.variably_sized) {
        // variable-size elements: each element prefixed with its size
        msa.add("    for (size_t i = 0; i < count; ++i) {");
        msa.add("        // element is variably sized: read elem_size first");
        msa.add("        if (offset + sizeof(size_t) > buffer.size()) break;");
        msa.add("        size_t elem_size;");
        msa.add("        std::memcpy(&elem_size, buffer.data() + offset, sizeof(size_t));");
        msa.add("        offset += sizeof(size_t);");
        msa.add("        if (offset + elem_size > buffer.size()) break;");
        msa.add("        std::vector<uint8_t> elem_buf(buffer.begin() + offset, buffer.begin() + offset + elem_size);");
        msa.add("        ", inner, " elem = element_deserializer(elem_buf);");
        msa.add("        result.push_back(elem);");
        msa.add("        offset += elem_size;");
        msa.add("    }");
    } else {
        // fixed-size elements: read sizeof(inner) bytes per element
        msa.add("    size_t elem_size = sizeof(", inner, ");");
        msa.add("    if (offset + count * elem_size > buffer.size()) return result; // safety check");
        msa.add("    for (size_t i = 0; i < count; ++i) {");
        msa.add("        std::vector<uint8_t> elem_buf(buffer.begin() + offset, buffer.begin() + offset + elem_size);");
        msa.add("        ", inner, " elem = element_deserializer(elem_buf);");
        msa.add("        result.push_back(elem);");
        msa.add("        offset += elem_size;");
        msa.add("    }");
    }

    msa.add("    return result;");
    msa.add("}");

    return msa.str();
}

std::string create_string_to_array_of_type_func(MetaType type_parameter, unsigned int size) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::string &input) -> std::array<", type_parameter.get_type_name(), ", ", std::to_string(size),
            "> {");
    msa.add("    std::string trimmed = input;");
    msa.add("    if (!trimmed.empty() && trimmed.front() == '{' && trimmed.back() == '}') {");
    msa.add("        trimmed = trimmed.substr(1, trimmed.size() - 2);");
    msa.add("    }");
    msa.add("");
    msa.add("    std::array<", type_parameter.get_type_name(), ", ", std::to_string(size), "> result{};");
    msa.add("    std::regex element_re(R\"(", type_parameter.literal_regex, ")\");");
    msa.add("    auto begin = std::sregex_iterator(trimmed.begin(), trimmed.end(), element_re);");
    msa.add("    auto end = std::sregex_iterator();");
    msa.add("");
    msa.add("    size_t idx = 0;");
    msa.add("    for (auto it = begin; it != end && idx < ", std::to_string(size), "; ++it, ++idx) {");
    msa.add("        try {");
    msa.add("            auto conversion = ", type_parameter.string_to_type_func_lambda, ";");
    msa.add("            result[idx] = conversion(it->str());");
    msa.add("        } catch (...) {");
    msa.add("            // Ignore malformed elements");
    msa.add("        }");
    msa.add("    }");
    msa.add("    return result;");
    msa.add("}");

    return msa.str();
}

std::string create_array_of_type_to_string_func(MetaType type_parameter, unsigned int size) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::array<", type_parameter.get_type_name(), ", ", std::to_string(size),
            ">& arr) -> std::string {");
    msa.add("    std::ostringstream oss;");
    msa.add("    oss << \"{\";");
    msa.add("    auto conversion = ", type_parameter.type_to_string_func_lambda, ";");
    msa.add("");
    msa.add("    for (size_t i = 0; i < arr.size(); ++i) {");
    msa.add("        oss << conversion(arr[i]);");
    msa.add("        if (i + 1 < arr.size())");
    msa.add("            oss << \", \";");
    msa.add("    }");
    msa.add("");
    msa.add("    oss << \"}\";");
    msa.add("    return oss.str();");
    msa.add("}");

    return msa.str();
}

std::string create_array_of_type_serialize_func(MetaType type_parameter, unsigned int size) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::array<", type_parameter.get_type_name(), ", ", std::to_string(size),
            ">& arr) -> std::vector<uint8_t> {");
    msa.add("    std::vector<uint8_t> buffer;");

    msa.add("    auto element_serializer = ", type_parameter.serialize_type_func_lambda, ";");

    if (type_parameter.variably_sized) {
        msa.add("    for (const auto& elem : arr) {");
        msa.add("        auto elem_bytes = element_serializer(elem);");
        msa.add("        size_t elem_size = elem_bytes.size();");
        msa.add("        buffer.resize(buffer.size() + sizeof(size_t));");
        msa.add("        std::memcpy(buffer.data() + buffer.size() - sizeof(size_t), &elem_size, sizeof(size_t));");
        msa.add("        buffer.insert(buffer.end(), elem_bytes.begin(), elem_bytes.end());");
        msa.add("    }");
    } else {
        msa.add("    if (!arr.empty()) {");
        msa.add("        size_t elem_size = sizeof(", type_parameter.get_type_name(), ");");
        msa.add("        buffer.resize(buffer.size() + arr.size() * elem_size);");
        msa.add("        std::memcpy(buffer.data(), arr.data(), arr.size() * elem_size);");
        msa.add("    }");
    }

    msa.add("    return buffer;");
    msa.add("}");

    return msa.str();
}

std::string create_array_of_type_serialized_size_func(MetaType type_parameter, unsigned int size) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::array<", type_parameter.get_type_name(), ", ", std::to_string(size), ">& arr) -> size_t {");
    msa.add("    size_t total_size = 0;");

    auto element_size_lambda = type_parameter.size_when_serialized_bytes_func_lambda;

    if (type_parameter.variably_sized) {
        // variable-size inner type
        msa.add("    for (const auto& elem : arr) {");
        msa.add("        total_size += sizeof(size_t); // store element size prefix");
        msa.add("        total_size += ", element_size_lambda, "(elem);");
        msa.add("    }");
    } else {
        // fixed-size inner type
        msa.add("    if (!arr.empty()) {");
        msa.add("        total_size += arr.size() * ", element_size_lambda, "(arr[0]);");
        msa.add("    }");
    }

    msa.add("    return total_size;");
    msa.add("}");

    return msa.str();
}

std::string create_array_of_type_deserialize_func(MetaType type_parameter, unsigned int size) {
    text_utils::MultilineStringAccumulator msa;

    const std::string &inner = type_parameter.get_type_name();

    msa.add("[=](const std::vector<uint8_t>& buffer) -> std::array<", inner, ", ", std::to_string(size), "> {");
    msa.add("    std::array<", inner, ", ", std::to_string(size), "> result{};");
    msa.add("    auto element_deserializer = ", type_parameter.deserialize_type_func_lambda, ";");
    msa.add("");
    msa.add("    size_t offset = 0;");

    if (type_parameter.variably_sized) {
        msa.add("    for (size_t i = 0; i < ", std::to_string(size), "; ++i) {");
        msa.add("        if (offset + sizeof(size_t) > buffer.size()) break;");
        msa.add("        size_t elem_size;");
        msa.add("        std::memcpy(&elem_size, buffer.data() + offset, sizeof(size_t));");
        msa.add("        offset += sizeof(size_t);");
        msa.add("        if (offset + elem_size > buffer.size()) break;");
        msa.add("        std::vector<uint8_t> elem_buf(buffer.begin() + offset, buffer.begin() + offset + elem_size);");
        msa.add("        result[i] = element_deserializer(elem_buf);");
        msa.add("        offset += elem_size;");
        msa.add("    }");
    } else {
        msa.add("    size_t elem_size = sizeof(", inner, ");");
        msa.add("    if (buffer.size() < ", std::to_string(size), " * elem_size) return result;");
        msa.add("    for (size_t i = 0; i < ", std::to_string(size), "; ++i) {");
        msa.add("        std::vector<uint8_t> elem_buf(buffer.begin() + offset, buffer.begin() + offset + elem_size);");
        msa.add("        result[i] = element_deserializer(elem_buf);");
        msa.add("        offset += elem_size;");
        msa.add("    }");
    }

    msa.add("    return result;");
    msa.add("}");

    return msa.str();
}

std::string create_string_to_unordered_map_func(MetaType key_type, MetaType value_type) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::string &input) -> std::unordered_map<", key_type.get_type_name(), ", ",
            value_type.get_type_name(), "> {");
    msa.add("    std::string trimmed = input;");
    msa.add("    if (!trimmed.empty() && trimmed.front() == '{' && trimmed.back() == '}') {");
    msa.add("        trimmed = trimmed.substr(1, trimmed.size() - 2);");
    msa.add("    }");
    msa.add("");
    msa.add("    std::unordered_map<", key_type.get_type_name(), ", ", value_type.get_type_name(), "> result;");
    msa.add("    std::regex pair_re(R\"(([^:]+):([^,]+))\"); // simple key:value parser");
    msa.add("    auto begin = std::sregex_iterator(trimmed.begin(), trimmed.end(), pair_re);");
    msa.add("    auto end = std::sregex_iterator();");
    msa.add("");
    msa.add("    auto key_conv = ", key_type.string_to_type_func_lambda, ";");
    msa.add("    auto val_conv = ", value_type.string_to_type_func_lambda, ";");
    msa.add("");
    msa.add("    for (auto it = begin; it != end; ++it) {");
    msa.add("        try {");
    msa.add("            auto key = key_conv(it->str(1));");
    msa.add("            auto val = val_conv(it->str(2));");
    msa.add("            result[key] = val;");
    msa.add("        } catch (...) {");
    msa.add("            // ignore malformed pairs");
    msa.add("        }");
    msa.add("    }");
    msa.add("    return result;");
    msa.add("}");

    return msa.str();
}

std::string create_unordered_map_to_string_func(MetaType key_type, MetaType value_type) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::unordered_map<", key_type.get_type_name(), ", ", value_type.get_type_name(),
            ">& map) -> std::string {");
    msa.add("    std::ostringstream oss;");
    msa.add("    oss << \"{\";");
    msa.add("    auto key_conv = ", key_type.type_to_string_func_lambda, ";");
    msa.add("    auto val_conv = ", value_type.type_to_string_func_lambda, ";");
    msa.add("");
    msa.add("    bool first = true;");
    msa.add("    for (const auto& kv : map) {");
    msa.add("        if (!first) oss << \", \";");
    msa.add("        oss << key_conv(kv.first) << \":\" << val_conv(kv.second);");
    msa.add("        first = false;");
    msa.add("    }");
    msa.add("    oss << \"}\";");
    msa.add("    return oss.str();");
    msa.add("}");

    return msa.str();
}

std::string create_unordered_map_serialize_func(MetaType key_type, MetaType value_type) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::unordered_map<", key_type.get_type_name(), ", ", value_type.get_type_name(),
            ">& map) -> std::vector<uint8_t> {");
    msa.add("    std::vector<uint8_t> buffer;");
    msa.add("    size_t count = map.size();");
    msa.add("    buffer.resize(sizeof(size_t));");
    msa.add("    std::memcpy(buffer.data(), &count, sizeof(size_t));");
    msa.add("");
    msa.add("    auto key_ser = ", key_type.serialize_type_func_lambda, ";");
    msa.add("    auto val_ser = ", value_type.serialize_type_func_lambda, ";");
    msa.add("");
    msa.add("    for (const auto& kv : map) {");
    msa.add("        auto key_bytes = key_ser(kv.first);");
    msa.add("        auto val_bytes = val_ser(kv.second);");
    msa.add("        size_t key_size = key_bytes.size();");
    msa.add("        size_t val_size = val_bytes.size();");
    msa.add("        buffer.resize(buffer.size() + sizeof(size_t) * 2);");
    msa.add("        std::memcpy(buffer.data() + buffer.size() - sizeof(size_t) * 2, &key_size, sizeof(size_t));");
    msa.add("        std::memcpy(buffer.data() + buffer.size() - sizeof(size_t), &val_size, sizeof(size_t));");
    msa.add("        buffer.insert(buffer.end(), key_bytes.begin(), key_bytes.end());");
    msa.add("        buffer.insert(buffer.end(), val_bytes.begin(), val_bytes.end());");
    msa.add("    }");
    msa.add("    return buffer;");
    msa.add("}");

    return msa.str();
}

std::string create_unordered_map_serialized_size_func(MetaType key_type, MetaType value_type) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::unordered_map<", key_type.get_type_name(), ", ", value_type.get_type_name(),
            ">& map) -> size_t {");
    msa.add("    size_t total = sizeof(size_t);");
    msa.add("    auto key_size_func = ", key_type.size_when_serialized_bytes_func_lambda, ";");
    msa.add("    auto val_size_func = ", value_type.size_when_serialized_bytes_func_lambda, ";");
    msa.add("");
    msa.add("    for (const auto& kv : map) {");
    msa.add("        total += sizeof(size_t) * 2;");
    msa.add("        total += key_size_func(kv.first);");
    msa.add("        total += val_size_func(kv.second);");
    msa.add("    }");
    msa.add("    return total;");
    msa.add("}");

    return msa.str();
}

std::string create_unordered_map_deserialize_func(MetaType key_type, MetaType value_type) {
    text_utils::MultilineStringAccumulator msa;

    msa.add("[=](const std::vector<uint8_t>& buffer) -> std::unordered_map<", key_type.get_type_name(), ", ",
            value_type.get_type_name(), "> {");
    msa.add("    std::unordered_map<", key_type.get_type_name(), ", ", value_type.get_type_name(), "> result;");
    msa.add("    if (buffer.size() < sizeof(size_t)) return result;");
    msa.add("");
    msa.add("    size_t count;");
    msa.add("    std::memcpy(&count, buffer.data(), sizeof(size_t));");
    msa.add("    size_t offset = sizeof(size_t);");
    msa.add("");
    msa.add("    auto key_deser = ", key_type.deserialize_type_func_lambda, ";");
    msa.add("    auto val_deser = ", value_type.deserialize_type_func_lambda, ";");
    msa.add("");
    msa.add("    for (size_t i = 0; i < count; ++i) {");
    msa.add("        if (offset + sizeof(size_t) * 2 > buffer.size()) break;");
    msa.add("        size_t key_size, val_size;");
    msa.add("        std::memcpy(&key_size, buffer.data() + offset, sizeof(size_t));");
    msa.add("        std::memcpy(&val_size, buffer.data() + offset + sizeof(size_t), sizeof(size_t));");
    msa.add("        offset += sizeof(size_t) * 2;");
    msa.add("        if (offset + key_size + val_size > buffer.size()) break;");
    msa.add("        std::vector<uint8_t> key_buf(buffer.begin() + offset, buffer.begin() + offset + key_size);");
    msa.add("        offset += key_size;");
    msa.add("        std::vector<uint8_t> val_buf(buffer.begin() + offset, buffer.begin() + offset + val_size);");
    msa.add("        offset += val_size;");
    msa.add("        auto key = key_deser(key_buf);");
    msa.add("        auto val = val_deser(val_buf);");
    msa.add("        result[key] = val;");
    msa.add("    }");
    msa.add("    return result;");
    msa.add("}");

    return msa.str();
}

MetaType resolve_meta_type(const std::string &type_str, const MetaTypes &types) {
    // 1. Try concrete lookup first
    const auto &concrete_map = types.get_concrete_type_name_to_meta_type();
    auto it = concrete_map.find(type_str);
    if (it != concrete_map.end()) {
        return it->second;
    }

    // 2. Try generic lookup (e.g., std::vector<int>, std::array<int, 5>)
    auto lt_pos = type_str.find('<');
    auto gt_pos = type_str.rfind('>');
    if (lt_pos != std::string::npos && gt_pos != std::string::npos && gt_pos > lt_pos) {
        std::string generic_name = type_str.substr(0, lt_pos);
        std::string params_str = type_str.substr(lt_pos + 1, gt_pos - lt_pos - 1);

        // split parameters by commas
        // NOTE: assumes simple case: no nested templates yet
        std::vector<std::string> param_tokens;
        {
            std::stringstream ss(params_str);
            std::string token;
            while (std::getline(ss, token, ',')) {
                // trim
                token.erase(0, token.find_first_not_of(" \t"));
                token.erase(token.find_last_not_of(" \t") + 1);
                param_tokens.push_back(token);
            }
        }

        // convert tokens into TemplateParameters
        std::vector<MetaTemplateParameter> template_parameters;
        for (const auto &tok : param_tokens) {
            bool is_number = !tok.empty() && std::all_of(tok.begin(), tok.end(), ::isdigit);

            if (is_number) {
                template_parameters.emplace_back(static_cast<unsigned int>(std::stoul(tok)));
            } else {
                // recursively resolve type argument
                template_parameters.emplace_back(resolve_meta_type(tok, types));
            }
        }

        // lookup generic constructor
        auto &generic_map = types.get_generic_type_to_meta_type_constructor();
        auto gen_it = generic_map.find(generic_name);
        if (gen_it != generic_map.end()) {
            return gen_it->second(template_parameters);
        }
    }

    throw std::runtime_error("Unknown type in MetaTypes: " + type_str);
}

MetaClass create_meta_class_or_struct_from_source(
    const std::string &source,
    cpp_parsing::CharParserPtr def_parser, // class_def_parser_good or struct_def_parser_good
    const std::string &unnamed_fallback,   // "UnnamedClass" or "UnnamedStruct"
    const std::string &kind                // "class" or "struct" (for logging)
) {
    std::cout << "[create_meta_" << kind << "_from_source] BEGIN\n";
    std::cout << "[source]\n" << source << "\n";

    // 1) parse
    auto pr = def_parser->parse(source, 0);

    // 2) find name
    const cpp_parsing::ParseResult *name_node = cpp_parsing::find_first_by_name(&pr, "variable");
    if (!name_node)
        name_node = cpp_parsing::find_first_by_name(&pr, "identifier");

    std::string name = name_node ? text_utils::trim(cpp_parsing::node_text(name_node)) : unnamed_fallback;
    std::cout << "[" << kind << " name] " << name << "\n";

    MetaClass mc(name);

    // 3) find nested_braces
    const cpp_parsing::ParseResult *nested = cpp_parsing::find_first_by_name(&pr, "nested_braces");
    if (!nested) {
        std::cerr << "[error] No nested_braces found — returning empty MetaClass for " << name << "\n";
        return mc;
    }

    // 4) collect declarations + assignments
    std::vector<const cpp_parsing::ParseResult *> members;
    cpp_parsing::collect_by_name(nested, "declaration", members);
    cpp_parsing::collect_by_name(nested, "assignment", members);
    std::cout << "[members count] " << members.size() << "\n";

    // --- Helpers ---
    auto extract_type_text = [&](const cpp_parsing::ParseResult *decl_node) -> std::string {
        const cpp_parsing::ParseResult *type_node = cpp_parsing::find_first_name_contains(decl_node, "type");
        if (!type_node)
            type_node = cpp_parsing::find_first_by_name(decl_node, "non_templated_type");
        if (!type_node)
            type_node = cpp_parsing::find_first_by_name(decl_node, "sequence");
        if (type_node)
            return text_utils::trim(cpp_parsing::node_text(type_node));

        for (const auto &child : decl_node->sub_results) {
            if (child.parser_name == "identifier" || child.parser_name == "variable")
                break;
            if (!text_utils::trim(child.match).empty())
                return text_utils::trim(child.match);
        }
        return "int"; // fallback
    };

    auto extract_variable_name = [&](const cpp_parsing::ParseResult *decl_node) -> std::string {
        const cpp_parsing::ParseResult *var_node = cpp_parsing::find_first_by_name(decl_node, "variable");
        if (!var_node)
            var_node = cpp_parsing::find_first_by_name(decl_node, "identifier");
        if (var_node)
            return text_utils::trim(cpp_parsing::node_text(var_node));

        for (const auto &child : decl_node->sub_results) {
            std::string t = text_utils::trim(child.match);
            if (!t.empty() && std::isalpha((unsigned char)t[0]))
                return t;
        }
        return "unnamed";
    };

    auto extract_initializer = [&](const cpp_parsing::ParseResult *decl_node)
        -> std::optional<std::pair<std::string, MetaVariable::InitStyle>> {
        const cpp_parsing::ParseResult *assign_node = cpp_parsing::find_first_by_name(decl_node, "assignment");
        if (assign_node)
            return std::make_pair(text_utils::trim(cpp_parsing::node_text(assign_node)),
                                  MetaVariable::InitStyle::Assignment);

        for (const auto &child : decl_node->sub_results) {
            if (text_utils::trim(child.match) == "=") {
                std::string rhs;
                bool started = false;
                for (const auto &sibling : decl_node->sub_results) {
                    if (!started) {
                        if (&sibling == &child)
                            started = true;
                        continue;
                    }
                    std::string t = text_utils::trim(sibling.match);
                    if (t == ";")
                        break;
                    if (!rhs.empty())
                        rhs += " ";
                    rhs += t;
                }
                if (!rhs.empty())
                    return std::make_pair(rhs, MetaVariable::InitStyle::Assignment);
            }
            if (child.match.find('{') != std::string::npos) {
                std::string body = text_utils::trim(cpp_parsing::node_text(&child));
                return std::make_pair(body, MetaVariable::InitStyle::Brace);
            }
        }
        return std::nullopt;
    };

    // 5) iterate members
    for (size_t i = 0; i < members.size(); ++i) {
        const cpp_parsing::ParseResult *decl = members[i];

        std::string type_text = extract_type_text(decl);
        std::string var_name = extract_variable_name(decl);

        std::string value_text = "{}";
        MetaVariable::InitStyle init_style = MetaVariable::InitStyle::Assignment;

        if (auto maybe_init = extract_initializer(decl)) {
            value_text = maybe_init->first;
            init_style = maybe_init->second;
        }

        MetaVariable mv(type_text, var_name, value_text, init_style);
        MetaAttribute ma(std::move(mv));
        mc.add_attribute(ma);
    }

    std::cout << "[create_meta_" << kind << "_from_source] END\n";
    return mc;
}

meta_utils::MetaClass create_meta_class_from_source(const std::string &source) {
    return meta_utils::create_meta_class_or_struct_from_source(source, cpp_parsing::class_def_parser_good,
                                                               "UnnamedClass", "class");
}

meta_utils::MetaClass create_meta_struct_from_source(const std::string &source) {
    return meta_utils::create_meta_class_or_struct_from_source(source, cpp_parsing::struct_def_parser_good,
                                                               "UnnamedStruct", "struct");
}

meta_utils::MetaType create_meta_type_from_using(const std::string &source, const meta_utils::MetaTypes &types) {

    auto pr = cpp_parsing::using_statement_parser->parse(source, 0);

    if (!pr.succeeded) {
        throw std::runtime_error("Failed to parse using statement: " + source);
    }

    // Find alias name
    auto alias_node = cpp_parsing::find_first_by_name(&pr, "variable");
    if (!alias_node) {
        throw std::runtime_error("Could not find alias name in using statement: " + source);
    }
    std::string alias_name = cpp_parsing::node_text(alias_node);

    // Find the type (look for parser whose name contains "type")
    auto type_node = cpp_parsing::find_first_name_contains(&pr, "type");
    if (!type_node) {
        throw std::runtime_error("Could not find type in using statement: " + source);
    }
    std::string type_str = cpp_parsing::node_text(type_node);

    // Resolve type string
    auto resolved_type = meta_utils::resolve_meta_type(type_str, types);

    // Create alias MetaType
    meta_utils::MetaType alias_mt = resolved_type;
    alias_mt.base_type_name = alias_name; // alias overrides the underlying type name

    // we clear this because we don't want it to print out, because it's an alias.
    alias_mt.template_parameters.clear();

    return alias_mt;
}

meta_utils::MetaEnum create_meta_enum_from_source(const std::string &source) {
    std::cout << "[create_meta_enum_from_source] BEGIN\n";
    std::cout << "[source]\n" << source << "\n";

    // 1) parse
    auto pr = cpp_parsing::enum_class_def_parser->parse(source, 0);
    std::cout << "[parse result]\n" << pr.to_string() << "\n";

    // 2) find enum name
    const cpp_parsing::ParseResult *name_node = cpp_parsing::find_first_by_name(&pr, "variable");
    std::string enum_name = name_node ? text_utils::trim(cpp_parsing::node_text(name_node)) : "UnnamedEnum";
    std::cout << "[enum name] " << enum_name << "\n";

    // 3) find underlying type (inheritance node)
    const cpp_parsing::ParseResult *inheritance_node = cpp_parsing::find_first_by_name(&pr, "class_inheritance");
    std::string enum_type = "int"; // default
    if (inheritance_node) {
        const cpp_parsing::ParseResult *type_node = cpp_parsing::find_first_by_name(inheritance_node, "variable");
        if (type_node) {
            enum_type = text_utils::trim(cpp_parsing::node_text(type_node));
        }
    }
    std::cout << "[enum type] " << enum_type << "\n";

    meta_utils::MetaEnum me;
    me.name = enum_name;
    me.type = enum_type;

    // 4) extract nested braces with the enumerators
    const cpp_parsing::ParseResult *nested = cpp_parsing::find_first_by_name(&pr, "nested_braces");
    if (!nested) {
        std::cerr << "[error] No nested_braces found — returning empty MetaEnum for " << enum_name << "\n";
        return me;
    }
    std::cout << "[nested_braces found]\n" << nested->to_string() << "\n";

    // 5) collect enum values
    std::vector<const cpp_parsing::ParseResult *> values;
    cpp_parsing::collect_by_name(nested, "variable", values);
    std::cout << "[enum values count] " << values.size() << "\n";

    for (size_t i = 0; i < values.size(); ++i) {
        std::string value_name = text_utils::trim(cpp_parsing::node_text(values[i]));
        if (!value_name.empty()) {
            std::cout << "  [enum value] '" << value_name << "'\n";
            me.enum_names.push_back(value_name);
        }
    }

    std::cout << "[create_meta_enum_from_source] END\n";
    return me;
}

std::unordered_map<char, char> replacement_map = {{':', '_'}, {' ', '_'}};
std::string to_string_function_name(const std::string &type) {
    return text_utils::replace_chars(type, replacement_map) + "_to_string";
}
std::string from_string_function_name(const std::string &type) {
    return "string_to_" + text_utils::replace_chars(type, replacement_map);
}
std::string serialize_function_name(const std::string &type) {
    return "serialize_" + text_utils::replace_chars(type, replacement_map);
}

std::string size_when_serialized_function_name(const std::string &type) {
    return "size_when_serialized_" + text_utils::replace_chars(type, replacement_map);
}

std::string deserialize_function_name(const std::string &type) {
    return "deserialize_" + text_utils::replace_chars(type, replacement_map);
}

MetaType construct_class_metatype(const MetaClass &cls, const MetaTypes &types) {
    text_utils::MultilineStringAccumulator to_string_func;
    text_utils::MultilineStringAccumulator from_string_func;
    text_utils::MultilineStringAccumulator serialize_func;
    text_utils::MultilineStringAccumulator deserialize_func;
    text_utils::MultilineStringAccumulator size_func;

    bool variably_sized = false;

    for (size_t i = 0; i < cls.attributes.size(); ++i) {
        const auto &attr = cls.attributes[i];
        auto meta = resolve_meta_type(attr.variable.type, types);
        if (meta.variably_sized) {
            variably_sized = true;
        }
    }

    // ---------- To String ----------
    to_string_func.add("[=](const ", cls.name, "& obj) -> std::string {");
    to_string_func.add("    std::ostringstream oss;");
    to_string_func.add("    oss << \"{\";");

    for (size_t i = 0; i < cls.attributes.size(); ++i) {
        const auto &attr = cls.attributes[i];
        auto meta = resolve_meta_type(attr.variable.type, types);

        // TODO: need to reuse previous functions one day
        to_string_func.add("    { auto conv = ", meta.type_to_string_func_lambda, ";");
        to_string_func.add("      oss << \"", attr.variable.name, "=\" << conv(obj.", attr.variable.name, "); }");
        //
        // to_string_func.add("    { oss << \"", attr.variable.name, "=\" << ",
        //                    to_string_function_name(meta.base_type_name), "(obj.", attr.variable.name, "); }");

        if (i + 1 < cls.attributes.size())
            to_string_func.add("    oss << \", \";");
    }

    to_string_func.add("    oss << \"}\";");
    to_string_func.add("    return oss.str();");
    to_string_func.add("}");

    // ---------- From String ----------
    from_string_func.add("[=](const std::string &s) -> ", cls.name, " {");
    from_string_func.add("    ", cls.name, " obj;");
    from_string_func.add("    std::string trimmed = s.substr(1, s.size() - 2); // remove {}");
    from_string_func.add("    std::istringstream iss(trimmed);");
    from_string_func.add("    std::string token;");

    for (const auto &attr : cls.attributes) {
        auto meta = resolve_meta_type(attr.variable.type, types);

        from_string_func.add("    if (std::getline(iss, token, ',')) {");
        from_string_func.add("        auto pos = token.find('=');");
        from_string_func.add("        if (pos != std::string::npos) {");
        from_string_func.add("            std::string value_str = token.substr(pos + 1);");
        from_string_func.add("            auto conv = ", meta.string_to_type_func_lambda, ";");
        from_string_func.add("            obj.", attr.variable.name, " = conv(value_str);");
        from_string_func.add("        }");
        from_string_func.add("    }");
    }

    from_string_func.add("    return obj;");
    from_string_func.add("}");

    // ---------- Serialize ----------
    serialize_func.add("[=](const ", cls.name, "& obj) -> std::vector<uint8_t> {");
    serialize_func.add("    std::vector<uint8_t> buffer;");

    for (const auto &attr : cls.attributes) {
        auto meta = resolve_meta_type(attr.variable.type, types);
        serialize_func.add("    { auto ser = ", meta.serialize_type_func_lambda, ";");
        serialize_func.add("      auto bytes = ser(obj.", attr.variable.name, ");");

        if (meta.variably_sized) {
            // prepend size for variable-size attributes
            serialize_func.add("      size_t len = bytes.size();");
            serialize_func.add("      buffer.resize(buffer.size() + sizeof(size_t));");
            serialize_func.add(
                "      std::memcpy(buffer.data() + buffer.size() - sizeof(size_t), &len, sizeof(size_t));");
        }

        serialize_func.add("      buffer.insert(buffer.end(), bytes.begin(), bytes.end()); }");
    }

    serialize_func.add("    return buffer;");
    serialize_func.add("}");

    // ---------- Deserialize ----------
    deserialize_func.add("[=](const std::vector<uint8_t> &buffer) -> ", cls.name, " {");
    deserialize_func.add("    ", cls.name, " obj;");
    deserialize_func.add("    size_t offset = 0;");

    for (const auto &attr : cls.attributes) {
        auto meta = resolve_meta_type(attr.variable.type, types);

        deserialize_func.add("    { auto deser = ", meta.deserialize_type_func_lambda, ";");

        if (meta.variably_sized) {
            // variable-size: first read size prefix
            deserialize_func.add("      if (offset + sizeof(size_t) > buffer.size()) return obj;");
            deserialize_func.add("      size_t len = 0;");
            deserialize_func.add("      std::memcpy(&len, buffer.data() + offset, sizeof(size_t));");
            deserialize_func.add("      offset += sizeof(size_t);");
            deserialize_func.add("      if (offset + len > buffer.size()) return obj;");
            deserialize_func.add(
                "      std::vector<uint8_t> slice(buffer.begin() + offset, buffer.begin() + offset + len);");
            deserialize_func.add("      obj.", attr.variable.name, " = deser(slice);");
            deserialize_func.add("      offset += len;");
        } else {
            // fixed-size: use MetaType's serialized size func
            deserialize_func.add("      auto size_fn = ", meta.size_when_serialized_bytes_func_lambda, ";");
            deserialize_func.add("      size_t len = size_fn(obj.", attr.variable.name, ");");
            deserialize_func.add("      if (offset + len > buffer.size()) return obj;");
            deserialize_func.add(
                "      std::vector<uint8_t> slice(buffer.begin() + offset, buffer.begin() + offset + len);");
            deserialize_func.add("      obj.", attr.variable.name, " = deser(slice);");
            deserialize_func.add("      offset += len;");
        }

        deserialize_func.add("    }");
    }

    deserialize_func.add("    return obj;");
    deserialize_func.add("}");

    // ---------- Size When Serialized ----------
    size_func.add("[=](const ", cls.name, "& obj) -> size_t {");
    size_func.add("    size_t total = 0;");
    for (const auto &attr : cls.attributes) {
        auto meta = resolve_meta_type(attr.variable.type, types);
        size_func.add("    { auto size_fn = ", meta.size_when_serialized_bytes_func_lambda, ";");
        if (meta.variably_sized) {
            size_func.add("      total += sizeof(size_t); // length prefix");
            size_func.add("      total += size_fn(obj.", attr.variable.name, "); }");
        } else {
            size_func.add("      total += size_fn(obj.", attr.variable.name, "); }");
        }
    }
    size_func.add("    return total;");
    size_func.add("}");

    auto mt = MetaType(cls.name, from_string_func.str(), to_string_func.str(), serialize_func.str(), size_func.str(),
                       deserialize_func.str(), regex_utils::any_char_greedy, {});
    mt.variably_sized = variably_sized;
    return mt;
}

MetaType construct_enum_metatype(const MetaEnum &enu, const MetaTypes &types) {
    text_utils::MultilineStringAccumulator to_string_func;
    text_utils::MultilineStringAccumulator from_string_func;
    text_utils::MultilineStringAccumulator serialize_func;
    text_utils::MultilineStringAccumulator deserialize_func;
    text_utils::MultilineStringAccumulator size_func;

    std::string fq_enum_name = enu.name; // e.g., "PacketType"
    std::string underlying = enu.type.empty() ? "int" : enu.type;

    // ---------- To String ----------
    to_string_func.add("[=](", fq_enum_name, " value) -> std::string {");
    to_string_func.add("    switch(value) {");

    for (const auto &name : enu.enum_names) {
        to_string_func.add("        case ", fq_enum_name, "::", name, ": return \"", fq_enum_name, "::", name, "\";");
    }

    to_string_func.add("        default: return \"<unknown ", fq_enum_name, ">\";");
    to_string_func.add("    }");
    to_string_func.add("}");

    // ---------- From String ----------
    from_string_func.add("[=](const std::string &s) -> ", fq_enum_name, " {");
    for (const auto &name : enu.enum_names) {
        from_string_func.add("    if (s == \"", fq_enum_name, "::", name, "\") return ", fq_enum_name, "::", name, ";");
    }
    from_string_func.add("    return static_cast<", fq_enum_name, ">(0); // default fallback");
    from_string_func.add("}");

    // ---------- Serialize ----------
    serialize_func.add("[=](", fq_enum_name, " value) -> std::vector<uint8_t> {");
    serialize_func.add("    std::vector<uint8_t> buffer(sizeof(", underlying, "));");
    serialize_func.add("    ", underlying, " raw = static_cast<", underlying, ">(value);");
    serialize_func.add("    std::memcpy(buffer.data(), &raw, sizeof(", underlying, "));");
    serialize_func.add("    return buffer;");
    serialize_func.add("}");

    // ---------- Deserialize ----------
    deserialize_func.add("[=](const std::vector<uint8_t> &buffer) -> ", fq_enum_name, " {");
    deserialize_func.add("    if (buffer.size() < sizeof(", underlying, ")) return static_cast<", fq_enum_name,
                         ">(0);");
    deserialize_func.add("    ", underlying, " raw = 0;");
    deserialize_func.add("    std::memcpy(&raw, buffer.data(), sizeof(", underlying, "));");
    deserialize_func.add("    return static_cast<", fq_enum_name, ">(raw);");
    deserialize_func.add("}");

    // ---------- Size When Serialized ----------
    size_func.add("[=](const ", fq_enum_name, " &obj) -> size_t {");
    size_func.add("    return sizeof(", underlying, ");");
    size_func.add("}");

    auto mt = MetaType(fq_enum_name, from_string_func.str(), to_string_func.str(), serialize_func.str(),
                       size_func.str(), deserialize_func.str(), regex_utils::any_char_greedy, {});
    mt.variably_sized = false;
    return mt;
}

// Extracts top-level comma-separated substrings from inside <...>
// e.g., split_template_args("int, std::vector<float>, std::map<int, double>")
//   → ["int", "std::vector<float>", "std::map<int, double>"]
std::vector<std::string> split_template_args(const std::string &s) {
    std::vector<std::string> args;
    int depth = 0;
    std::string current;

    for (char c : s) {
        if (c == '<') {
            depth++;
            current += c;
        } else if (c == '>') {
            depth--;
            current += c;
        } else if (c == ',' && depth == 0) {
            args.push_back(text_utils::trim(current));
            current.clear();
        } else {
            current += c;
        }
    }

    if (!current.empty()) {
        args.push_back(text_utils::trim(current));
    }

    return args;
}

std::string trim(const std::string &s) {
    size_t start = s.find_first_not_of(" \t\n\r");
    if (start == std::string::npos)
        return "";
    size_t end = s.find_last_not_of(" \t\n\r");
    return s.substr(start, end - start + 1);
}

std::vector<std::string> split_args(const std::string &args_str) {
    std::vector<std::string> args;
    std::string current;
    int depth = 0;
    for (char c : args_str) {
        if (c == ',' && depth == 0) {
            args.push_back(trim(current));
            current.clear();
        } else {
            if (c == '<' || c == '(')
                depth++;
            else if (c == '>' || c == ')')
                depth--;
            current += c;
        }
    }
    if (!current.empty())
        args.push_back(trim(current));
    return args;
}

std::string simplify_parameter(const std::string &param_str) {
    std::string s = param_str;

    // Remove default value
    auto eq_pos = s.find('=');
    if (eq_pos != std::string::npos)
        s = s.substr(0, eq_pos);

    // Trim
    auto trim = [](std::string &str) {
        str.erase(str.begin(),
                  std::find_if(str.begin(), str.end(), [](unsigned char ch) { return !std::isspace(ch); }));
        str.erase(std::find_if(str.rbegin(), str.rend(), [](unsigned char ch) { return !std::isspace(ch); }).base(),
                  str.end());
    };
    trim(s);

    // Remove leading "const "
    if (s.rfind("const ", 0) == 0)
        s = s.substr(6);

    // Tokenize
    std::istringstream iss(s);
    std::vector<std::string> tokens;
    std::string token;
    while (iss >> token)
        tokens.push_back(token);

    if (tokens.size() < 1)
        throw std::runtime_error("Invalid parameter: " + param_str);

    // Get the name token
    std::string name = tokens.back();
    tokens.pop_back();

    // If name is prefixed with & or *, put that back into the type
    std::string symbol_prefix;
    while (!name.empty() && (name[0] == '&' || name[0] == '*')) {
        symbol_prefix += name[0];
        name = name.substr(1);
    }

    // Reconstruct type
    std::string type;
    for (const auto &t : tokens)
        type += (type.empty() ? "" : " ") + t;

    type += symbol_prefix;

    // Remove all & and * from type
    type.erase(std::remove_if(type.begin(), type.end(), [](char c) { return c == '&' || c == '*'; }), type.end());

    trim(type);
    return type + " " + name;
}

std::string generate_regex_to_match_valid_invocation_of_func(const std::string &signature) {
    std::string return_type, func_name, args_str;
    std::string s = text_utils::trim(signature);

    bool parsed_regular = false;

    try {
        // --- Regular function parsing ---
        auto param_end = s.rfind(')');
        if (param_end == std::string::npos) {
            throw std::invalid_argument("Signature missing closing ')'");
        }

        auto param_start = s.rfind('(', param_end);
        if (param_start == std::string::npos) {
            throw std::invalid_argument("Signature missing opening '('");
        }

        args_str = s.substr(param_start + 1, param_end - param_start - 1);
        std::string ret_and_name = text_utils::trim(s.substr(0, param_start));

        auto last_space = ret_and_name.rfind(' ');
        if (last_space == std::string::npos) {
            throw std::invalid_argument("Cannot split return type and function name");
        }

        return_type = text_utils::trim(ret_and_name.substr(0, last_space));
        func_name = ret_and_name.substr(last_space + 1);

        parsed_regular = true;
    } catch (const std::invalid_argument &) {
        // Fallthrough → try constructor parsing
    }

    if (!parsed_regular) {
        // --- Constructor case (unchanged, still regex) ---
        std::smatch match;
        std::regex re(regex_utils::constructor_signature_re);
        if (!std::regex_match(s, match, re)) {
            std::cout << s << std::endl;
            throw std::invalid_argument("Invalid function or constructor signature");
        } else {
            return_type = match[1];
            func_name = match[1];
            args_str = match[2];
        }
    }

    // --- Process parameters ---
    auto args = split_args(args_str);

    std::vector<std::string> arg_types;
    static const std::regex param_re(R"(^\s*(.+?)\s+(\w+)(\s*=.*)?$)");

    for (auto &arg : args) {
        if (arg.empty())
            continue;

        arg = simplify_parameter(arg);

        std::smatch match;
        if (!std::regex_match(arg, match, param_re)) {
            throw std::invalid_argument("Each argument must match format: 'Type Name [= default]'. Got: " + arg);
        }

        std::string raw_type_str = match[1];
        std::string name = match[2];
        // std::string default_value = match[3]; // optional

        std::string cleaned_type_str = clean_type_string(raw_type_str);
        arg_types.push_back(cleaned_type_str);
    }

    // --- Build regex pattern for argument parsing ---
    std::vector<std::string> argument_literal_regexes;
    for (const auto &typ : arg_types) {
        auto mt = meta_utils::resolve_meta_type(typ);
        argument_literal_regexes.push_back(regex_utils::capture(mt.literal_regex));
    }

    std::string function_invocation_regex = text_utils::join(
        {regex_utils::start_of_line, func_name, "\\(",
         text_utils::join(argument_literal_regexes, regex_utils::optional_ws + "," + regex_utils::optional_ws), "\\)",
         regex_utils::end_of_line},
        regex_utils::optional_ws);

    return function_invocation_regex;
}

// NOTE: this is an important function
std::optional<MetaType> parse_meta_type_from_string(const std::string &type_str) {

    // // NOTE: using meta types here. so meta types must be defined first. REALLY BAD...
    // auto concrete_type_name_to_meta_type = meta_types.get_concrete_type_name_to_meta_type();
    //
    // std::string s = clean_type_string(type_str);
    //
    // if (auto it = concrete_type_name_to_meta_type.find(s); it != concrete_type_name_to_meta_type.end()) {
    //     return it->second;
    // } // now we know that the type is a generic type
    //
    // std::cout << type_str << " is not a concrete type" << std::endl;
    //
    // // try to match template type: base<...>
    // static const std::regex template_regex(R"((\w+(?:::\w+)*)\s*<\s*([^<>]+(?:<[^<>]+>[^<>]*)*)\s*>)");
    // std::smatch match;
    // if (std::regex_match(s, match, template_regex)) {
    //
    //     std::string base_type = match[1].str(); // e.g., "std::vector"
    //     std::string args_str = match[2].str();  // e.g., "int" or "std::string, std::vector<int>"
    //
    //     std::cout << "base_type: " << base_type << std::endl;
    //     std::cout << "args_str: " << args_str << std::endl;
    //
    //     // parse argument types recursively
    //     std::vector<std::string> inner_type_strs = split_template_args(args_str);
    //     std::vector<MetaType> inner_types;
    //
    //     for (const std::string &arg_str : inner_type_strs) {
    //
    //         auto maybe_inner = parse_meta_type_from_string(arg_str);
    //
    //         if (!maybe_inner)
    //             return std::nullopt; // fail if any inner type is unknown
    //         inner_types.push_back(*maybe_inner);
    //     }
    //
    //     // NOTE: only having support for vector right now.
    //     MetaType mt = meta_utils::generic_type_to_metatype_constructor.at(base_type)(inner_types.at(0));
    //
    //     return mt;
    // } else {
    //     std::cout << "regex didn't match : " << type_str << std::endl;
    // }

    return std::nullopt;
}

std::string clean_type_string(const std::string &raw_type) {
    std::string s = raw_type;

    // Remove 'const', 'volatile', '&', '*'
    static const std::regex modifiers(R"(\bconst\b|\bvolatile\b|&|\*)");
    s = std::regex_replace(s, modifiers, "");

    // Remove extra whitespace
    static const std::regex extra_spaces(R"(\s+)");
    s = std::regex_replace(s, extra_spaces, " ");

    // Trim leading/trailing space
    if (!s.empty() && s.front() == ' ')
        s.erase(s.begin());
    if (!s.empty() && s.back() == ' ')
        s.pop_back();

    return s;
}

std::string generate_string_invoker_for_function_with_string_return_type(const MetaFunctionSignature &sig) {
    const std::string &return_type = sig.return_type;
    const std::string &func_name = sig.name;

    // Find the type_to_string_func for the return type (except void)
    std::string return_type_to_string_func;
    if (return_type != "void" && return_type != "std::string") {
        auto meta_type = meta_utils::resolve_meta_type(return_type);
        return_type_to_string_func = meta_type.type_to_string_func_lambda;
    }

    // Compose the new function name
    std::string new_func_name = func_name + "_string_invoker_to_string";

    text_utils::MultilineStringAccumulator msa;

    msa.add("std::optional<std::string> ", new_func_name, "(const std::string &input) {");
    msa.add("    auto opt_result = ", func_name, "_string_invoker(input);");
    msa.add("    if (!opt_result) return std::nullopt;");

    if (return_type == "void") {
        msa.add("    return std::string(); // void returns empty string");
    } else if (return_type == "std::string") {
        msa.add("    return *opt_result;");
    } else {
        msa.add("    auto conversion = ", return_type_to_string_func, ";");
        msa.add("    return conversion(*opt_result);");
    }

    msa.add("}");

    return msa.str();
}

StringToTypeConversions get_code_to_generate_invocation(const std::vector<MetaParameter> &params) {
    std::vector<std::string> lambda_conversions;
    std::vector<std::string> arg_to_var_conversions;
    std::vector<std::string> arguments_to_final_func_call;
    for (size_t i = 0; i < params.size(); i++) {
        const auto &param = params[i];
        int group_num = static_cast<int>(i + 1);

        const std::string &string_to_type_func = param.type.string_to_type_func_lambda;

        std::string conversion_func_name = "conversion" + std::to_string(group_num);
        lambda_conversions.push_back("    auto " + conversion_func_name + " = " + string_to_type_func + ";");

        // NOTE: doing this because our parameter parsing is not good yet, and when something is a reference it gets
        // accidentally put into the name of the parameter, which is wrong and so accounting for it here.
        std::string fixed_param_name = param.name[0] == '&' ? param.name.substr(1) : param.name;

        // TODO: in the future we don't want to return optionals I believe, also this is a bad way of doing it
        bool returns_optional = text_utils::contains(string_to_type_func, "std::optional");

        std::string variable_assignment = "    " + param.type.get_type_name() + " " + fixed_param_name + " = " +
                                          conversion_func_name + "(match[" + std::to_string(group_num) + "])" +
                                          (returns_optional ? ".value()" : "") + ";";

        arg_to_var_conversions.push_back(variable_assignment);
        arguments_to_final_func_call.push_back(fixed_param_name);
    }
    return {lambda_conversions, arg_to_var_conversions, arguments_to_final_func_call};
}

std::string generate_string_invoker_for_function(const MetaFunctionSignature &sig, const std ::string &func_postfix) {
    const auto &params = sig.parameters;

    auto code_to_generate_invocation = get_code_to_generate_invocation(params);

    std::string function_invocation_regex = sig.invocation_regex;

    text_utils::MultilineStringAccumulator msa;

    // NOTE: we use the camel case because sometimes we operate on constructors which are in camel case
    msa.add("std::optional<", sig.return_type, "> ", text_utils::pascal_to_snake_case(sig.name), func_postfix,
            "(const std::string &invocation) {");
    msa.add("    std::regex re(R\"(", function_invocation_regex, ")\");");
    msa.add("    std::smatch match;");
    msa.add("    if (!std::regex_match(invocation, match, re)) return std::nullopt;");
    msa.add("");

    for (size_t i = 0; i < code_to_generate_invocation.arg_to_var_conversions.size(); ++i) {
        msa.add(code_to_generate_invocation.lambda_conversions[i]);
        msa.add(code_to_generate_invocation.arg_to_var_conversions[i]);
    }

    msa.add("");

    // call actual function
    msa.add("    ", sig.return_type, " result = ", get_fully_qualified_name(sig), "(",
            text_utils::join(code_to_generate_invocation.arguments_to_final_func_call, ", "), ");");
    msa.add("    return result;");

    msa.add("}");
    return msa.str();
}

std::string generate_deferred_string_invoker_for_function(const MetaFunctionSignature &sig,
                                                          const std ::string &func_postfix) {
    const auto &params = sig.parameters;

    auto code_to_generate_invocation = get_code_to_generate_invocation(params);

    std::string function_invocation_regex = sig.invocation_regex;

    text_utils::MultilineStringAccumulator msa;

    // NOTE: we use the camel case because sometimes we operate on constructors which are in camel case
    msa.add("std::optional<std::function<", sig.return_type, "()>> ", text_utils::pascal_to_snake_case(sig.name),
            func_postfix, "(const std::string &invocation) {");
    msa.add("    std::regex re(R\"(", function_invocation_regex, ")\");");
    msa.add("    std::smatch match;");
    msa.add("    if (!std::regex_match(invocation, match, re)) return std::nullopt;");
    msa.add("");

    for (size_t i = 0; i < code_to_generate_invocation.arg_to_var_conversions.size(); ++i) {
        msa.add(code_to_generate_invocation.lambda_conversions[i]);
        msa.add(code_to_generate_invocation.arg_to_var_conversions[i]);
    }

    msa.add("");

    msa.add("auto deferred_func = [&]() {");
    msa.add("    ", "return ", get_fully_qualified_name(sig), "(",
            text_utils::join(code_to_generate_invocation.arguments_to_final_func_call, ", "), ");");
    msa.add("};");

    msa.add("    return deferred_func;");

    msa.add("}");
    return msa.str();
}

// Helper join function for vector<string>
std::string join(const std::vector<std::string> &v, const std::string &sep) {
    std::string res;
    for (size_t i = 0; i < v.size(); i++) {
        res += v[i];
        if (i + 1 < v.size())
            res += sep;
    }
    return res;
}

// TODO: the below two functions are simply mappings, create a generic map function in collection utils one day
// NOTE: this will probably be removed in favor of the one that iterates over MetaFunctionSignatures
std::vector<MetaFunction> generate_string_invokers_to_string(std::vector<MetaFunction> mfs) {

    std::vector<MetaFunction> new_mfs;
    for (const auto &mf : mfs) {
        auto invoker_str_return_str =
            meta_utils::generate_string_invoker_for_function_with_string_return_type(mf.signature);
        meta_utils::MetaFunction invoker_return_string(invoker_str_return_str);
        new_mfs.push_back(invoker_str_return_str);
    }

    return new_mfs;
}

std::vector<MetaFunction> generate_string_invokers_to_string(std::vector<MetaFunctionSignature> mfss) {

    std::vector<MetaFunction> new_mfs;
    for (const auto &mfs : mfss) {
        auto invoker_str_return_str = meta_utils::generate_string_invoker_for_function_with_string_return_type(mfs);
        meta_utils::MetaFunction invoker_return_string(invoker_str_return_str);
        new_mfs.push_back(invoker_str_return_str);
    }

    return new_mfs;
}

// NOTE: this will probably be removed in favor of the one that iterates over MetaFunctionSignatures
std::vector<MetaVariable> generate_meta_function_signature_variables(std::vector<MetaFunction> meta_functions) {
    std::vector<MetaVariable> mf_vars;
    for (const auto &mf : meta_functions) {
        auto var_name = "mfs_" + mf.signature.name;
        // NOTE: we're using value as the parameters which is weird but it works.
        auto value = text_utils::join({text_utils::surround(mf.signature.to_string(), text_utils::double_quote),
                                       text_utils::surround(mf.name_space, text_utils::double_quote)},
                                      ", ");

        MetaVariable mv("meta_utils::MetaFunctionSignature", var_name, value, MetaVariable::InitStyle::Definition,
                        mf.name_space);
        mf_vars.push_back(mv);
    }
    return mf_vars;
}

std::vector<MetaVariable> generate_meta_function_signature_variables(std::vector<MetaFunctionSignature> mfss) {
    std::vector<MetaVariable> mf_vars;
    for (const auto &mfs : mfss) {
        auto var_name = "mfs_" + mfs.name;
        // NOTE: we're using value as the parameters which is weird but it works.
        auto value = text_utils::join({text_utils::surround(mfs.to_string(), text_utils::double_quote),
                                       text_utils::surround(mfs.name_space, text_utils::double_quote)},
                                      ", ");

        MetaVariable mv("meta_utils::MetaFunctionSignature", var_name, value, MetaVariable::InitStyle::Definition,
                        mfs.name_space);
        mf_vars.push_back(mv);
    }
    return mf_vars;
}

// NOTE: this is deprecated in favor of one that takes in meta function signatures
std::vector<MetaFunction> generate_string_invokers(std::vector<MetaFunction> mfs) {

    std::vector<MetaFunction> new_mfs;
    for (const auto &mf : mfs) {
        auto invoker_str = meta_utils::generate_string_invoker_for_function(mf.signature);
        meta_utils::MetaFunction invoker(invoker_str);

        new_mfs.push_back(invoker);

        // TODO: move elsewhere in future

        auto deferred_invoker_str = meta_utils::generate_deferred_string_invoker_for_function(mf.signature);
        meta_utils::MetaFunction deferred_invoker(deferred_invoker_str);

        new_mfs.push_back(deferred_invoker);
    }

    return new_mfs;
}

std::vector<MetaFunction> generate_string_invokers(std::vector<MetaFunctionSignature> mfss) {

    std::vector<MetaFunction> new_mfs;
    for (const auto &mfs : mfss) {
        auto invoker_str = meta_utils::generate_string_invoker_for_function(mfs);
        meta_utils::MetaFunction invoker(invoker_str);

        new_mfs.push_back(invoker);

        // TODO: move elsewhere in future

        auto deferred_invoker_str = meta_utils::generate_deferred_string_invoker_for_function(mfs);
        meta_utils::MetaFunction deferred_invoker(deferred_invoker_str);

        new_mfs.push_back(deferred_invoker);
    }

    return new_mfs;
}

std::vector<std::string> generate_type_grouped_invokers(const std::vector<meta_utils::MetaFunctionSignature> &mfss,
                                                        bool create_top_level_invoker) {
    std::unordered_map<std::string, std::vector<meta_utils::MetaFunctionSignature>> return_type_to_funcs;

    for (const auto &mfs : mfss) {
        return_type_to_funcs[mfs.return_type].push_back(mfs);
    }

    std::vector<std::string> type_grouped_invokers;
    for (const auto &[return_type, function_signatures] : return_type_to_funcs) {
        if (create_top_level_invoker and return_type == "std::string") {
            // We continue here because if you have a top level invoker, it will automatically be the
            // "invoker_that_returns_std_string"
            continue;
        }
        type_grouped_invokers.push_back(generate_string_invoker_for_function_collection_that_has_same_return_type(
            function_signatures, return_type, "_string_invoker"));
        // NOTE: also generating deferred invokers
        type_grouped_invokers.push_back(
            generate_deferred_string_invoker_for_function_collection_that_has_same_return_type(
                function_signatures, return_type, "_deferred_string_invoker"));
    }

    return type_grouped_invokers;
}

std::string sanitize_type(const std::string &type_str) {
    std::string fixed;
    fixed = text_utils::replace_substring(type_str, "::", "_");
    fixed = text_utils::replace_substring(fixed, ",", "_");
    fixed = text_utils::replace_substring(fixed, " ", "_");
    fixed = text_utils::replace_substring(fixed, "<", "_");
    fixed = text_utils::replace_substring(fixed, ">", "_");
    fixed = text_utils::remove_consecutive_duplicates(fixed, "_");
    return fixed;
}

std::string generate_string_invoker_for_function_collection_that_has_same_return_type(
    std::vector<MetaFunctionSignature> mfss_with_same_return_type, std::string return_type, std::string func_postfix) {
    std::ostringstream oss;

    oss << "std::optional<" << return_type << "> invoker_that_returns_" << sanitize_type(return_type)
        << "(const std::string &invocation) "
           "{\n\n";

    // Generate if-else chain for invocation matching
    for (const auto &mfs : mfss_with_same_return_type) {
        oss << "    if (std::regex_match(invocation, std::regex(mfs_" << mfs.name << ".invocation_regex))) {\n";
        oss << "        return " << mfs.name << func_postfix << "(invocation);\n";
        oss << "    }\n";
    }

    oss << "\n    return std::nullopt;\n";
    oss << "}\n";

    return oss.str();
}

MetaFunction
create_list_all_available_functions(std::vector<MetaCodeCollection> &generated_mcc_for_each_header_source_pair) {
    text_utils::MultilineStringAccumulator msa;
    msa.add("void list_all_available_functions() {");

    for (const auto &mcc : generated_mcc_for_each_header_source_pair) {
        std::string ns_label = mcc.name_space.empty() ? "<global>" : mcc.name_space;
        msa.add("    std::cout << \"--- Functions in namespace: " + ns_label + " ---\" << std::endl;");

        for (const auto &mc : mcc.classes) {
            msa.add("    for (const auto &mfs : " + text_utils::pascal_to_snake_case(mc.name) +
                    ".all_meta_function_signatures) {");
            msa.add("        std::cout << mfs.to_string() << std::endl;");
            msa.add("    }");
        }
    }

    msa.add("}");

    return MetaFunction(msa.str());
}

MetaFunction create_interactive_invoker() {
    text_utils::MultilineStringAccumulator msa;

    msa.add("void start_interactive_invoker() {");

    msa.add("std::map<std::string, meta_utils::MetaFunctionSignature> options_dict;");
    // TODO: fix hardcode here
    msa.add("    for (size_t i = 0; i < meta_text_utils.all_meta_function_signatures.size(); ++i) {");
    msa.add("    options_dict[std::to_string(i + 1)] = meta_text_utils.all_meta_function_signatures[i];");
    msa.add("}");

    msa.add("if (options_dict.empty()) {");
    msa.add("    std::cout << \"No functions available.\" << std::endl;");
    msa.add("    return; // nothing to do");
    msa.add("}");

    msa.add("std::vector<std::pair<std::string, meta_utils::MetaFunctionSignature>> "
            "sorted_options(options_dict.begin(), options_dict.end());");

    msa.add("std::sort(sorted_options.begin(), sorted_options.end(), [](const auto &a, const auto &b) { return "
            "std::stoi(a.first) < std::stoi(b.first); });");

    msa.add("bool keep_running = true;");

    msa.add("while (keep_running) {");
    msa.add("    std::cout << \"Select a function to invoke:\" << std::endl;;");
    msa.add("    for (const auto &[key, func] : sorted_options) {");
    msa.add("        std::cout << key << \". \" << func.to_string() << std::endl;");
    msa.add("    }");

    msa.add("    std::cout << \"q. Quit\" << std::endl;");

    msa.add("    std::string choice = get_validated_input( []() {");
    msa.add("        std::cout << \"Enter choice: \";");
    msa.add("        std::string s;");
    msa.add("        std::getline(std::cin, s);");
    msa.add("        return text_utils::trim(s);");
    msa.add("    },");
    msa.add("    [&](const std::string &input) { return input == \"q\" || options_dict.find(input) != "
            "options_dict.end(); }, \"Invalid choice. Please try again.\");");

    msa.add("    if (choice == \"q\") {");
    msa.add("        std::cout << \"Goodbye.\" << std::endl;");
    msa.add("        break;");
    msa.add("}");

    msa.add("    meta_utils::MetaFunctionSignature selected = options_dict[choice];");

    msa.add("    std::vector<std::string> args;");
    msa.add("    for (const auto &param : selected.parameters) {");
    msa.add("        std::string val = get_input_with_default(\"Enter value for \" + param.name + \" (\" + "
            "param.type.get_type_name() + \")\", \"0\");");
    msa.add("        args.push_back(val);");
    msa.add("    }");

    msa.add("    std::string invocation = selected.name + \"(\";");
    msa.add("    for (size_t i = 0; i < args.size(); ++i) {");
    msa.add("        invocation += args[i];");
    msa.add("        if (i < args.size() - 1) {");
    msa.add("            invocation += \", \";");
    msa.add("        }");
    msa.add("    }");
    msa.add("    invocation += \")\";");

    msa.add("    std::cout << \"about to run: \" << invocation << std::endl;");
    msa.add("    auto result = invoker_that_returns_std_string(invocation);");
    msa.add("    if (result.has_value()) {");
    msa.add("        std::cout << \"Result: \" << result.value() << std::endl;");
    msa.add("    } else {");
    msa.add("        std::cout << \"Invocation failed.\" << std::endl;");
    msa.add("    }");

    msa.add("    std::string run_again = get_validated_input(");
    msa.add("    []() {");
    msa.add("        std::cout << \"Do you want to run another function? (y/n): \";");
    msa.add("        std::string s;");
    msa.add("        std::getline(std::cin, s);");
    msa.add("        return text_utils::trim(s);");
    msa.add("    },");
    msa.add("    [](const std::string &input) { return input == \"y\" || input == \"n\"; }, \"Please enter 'y' or "
            "'n'.\");");

    msa.add("    if (run_again == \"n\") {");
    msa.add("        keep_running = false;");
    msa.add("        std::cout << \"Goodbye.\" << std::endl;");
    msa.add("    }");

    msa.add("}");
    msa.add("}");

    MetaFunction mf(msa.str());

    return mf;
}

std::string generate_deferred_string_invoker_for_function_collection_that_has_same_return_type(
    std::vector<MetaFunctionSignature> mfss_with_same_return_type, std::string return_type, std::string func_postfix) {
    std::ostringstream oss;

    oss << "std::optional<std::function<" << return_type << "()>> deferred_invoker_that_returns_"
        << sanitize_type(return_type)
        << "(const std::string &invocation) "
           "{\n\n";

    // Generate if-else chain for invocation matching
    for (const auto &mfs : mfss_with_same_return_type) {
        oss << "    if (std::regex_match(invocation, std::regex(mfs_" << mfs.name << ".invocation_regex))) {\n";
        oss << "        return " << mfs.name << func_postfix << "(invocation);\n";
        oss << "    }\n";
    }

    oss << "\n    return std::nullopt;\n";
    oss << "}\n";

    return oss.str();
}

std::string lambda_to_function(const std::string &lambda_str, const std::string &func_name,
                               const std::string &return_type) {
    // NOTE: just use the cppparser thing instead of this
    // Find parameter list
    auto params_start = lambda_str.find('(');
    auto params_end = lambda_str.find(')', params_start);
    if (params_start == std::string::npos || params_end == std::string::npos)
        throw std::invalid_argument("Lambda missing parameter list");

    std::string params_str = lambda_str.substr(params_start + 1, params_end - params_start - 1);

    // Find "-> return_type" if it exists
    std::string actual_return = return_type;
    auto arrow_pos = lambda_str.find("->", params_end);
    if (arrow_pos != std::string::npos) {
        auto brace_pos = lambda_str.find('{', arrow_pos);
        if (brace_pos == std::string::npos)
            throw std::invalid_argument("Malformed lambda: missing body after return type");

        actual_return = lambda_str.substr(arrow_pos + 2, brace_pos - (arrow_pos + 2));

        // trim
        actual_return.erase(0, actual_return.find_first_not_of(" \t\n\r"));
        actual_return.erase(actual_return.find_last_not_of(" \t\n\r") + 1);
    }

    // Extract body with brace balancing
    auto body_start = lambda_str.find('{', params_end);
    if (body_start == std::string::npos)
        throw std::invalid_argument("Lambda missing body");

    int depth = 0;
    size_t i = body_start;
    size_t body_end = std::string::npos;
    for (; i < lambda_str.size(); ++i) {
        if (lambda_str[i] == '{') {
            if (depth++ == 0)
                body_start = i + 1;
        } else if (lambda_str[i] == '}') {
            if (--depth == 0) {
                body_end = i;
                break;
            }
        }
    }
    if (body_end == std::string::npos)
        throw std::invalid_argument("Unbalanced braces in lambda");

    std::string body_str = lambda_str.substr(body_start, body_end - body_start);

    // trim
    auto trim = [](std::string &s) {
        s.erase(0, s.find_first_not_of(" \t\n\r"));
        s.erase(s.find_last_not_of(" \t\n\r") + 1);
    };
    trim(body_str);

    std::ostringstream oss;
    oss << actual_return << " " << func_name << "(" << params_str << ") {\n" << body_str << "\n}";
    return oss.str();
}
void register_custom_types_into_meta_types(const std::vector<CustomTypeExtractionSettings> &settings_list) {
    for (const auto &settings : settings_list) {
        register_custom_types_into_meta_types(settings);
    }
}

void register_custom_types_into_meta_types(const CustomTypeExtractionSettings &custom_type_extraction_settings) {

    auto root = cpp_parsing::parse_source_or_header_file(custom_type_extraction_settings.header_file_path);

    auto matches = cpp_parsing::bfs_collect_matches(
        &root, {cpp_parsing::class_def_parser->name, cpp_parsing::struct_def_parser->name,
                cpp_parsing::enum_class_def_parser->name, cpp_parsing::using_statement_parser->name});

    for (const auto &[parser_name, source] : matches) {

        meta_utils::MetaType custom_mt;

        if (parser_name == cpp_parsing::enum_class_def_parser->name) {
            auto me = meta_utils::create_meta_enum_from_source(source);
            custom_mt = construct_enum_metatype(me, meta_utils::meta_types);
        } else if (parser_name == cpp_parsing::class_def_parser->name) {
            auto mc = meta_utils::create_meta_class_from_source(source);
            custom_mt = construct_class_metatype(mc, meta_utils::meta_types);
        } else if (parser_name == cpp_parsing::struct_def_parser->name) {
            auto mc = meta_utils::create_meta_struct_from_source(source);
            custom_mt = construct_class_metatype(mc, meta_utils::meta_types);
        } else if (parser_name == cpp_parsing::using_statement_parser->name) {
            custom_mt = meta_utils::create_meta_type_from_using(source, meta_utils::meta_types);
        } else {
            // Unknown type, skip
            continue;
        }

        meta_utils::MetaInclude mi(custom_type_extraction_settings.header_file_path);
        custom_mt.includes_required.push_back(mi);

        // Iteratively register so later types can depend on earlier ones
        meta_utils::meta_types.add_new_concrete_type(custom_mt);
    }
}

// NOTE: this is becoming more general than that.
void generate_string_invokers_program_wide(std::vector<StringInvokerGenerationSettingsForHeaderSource> settings,
                                           const std::vector<MetaType> &all_types) {

    std::string output_header_path = "src/meta_program/meta_program.hpp";
    std::string output_source_path = "src/meta_program/meta_program.cpp";
    std::vector<std::string> paths = {output_header_path, output_source_path};

    bool there_is_a_bad_path = not collection_utils::all_of(
        collection_utils::map_vector(paths, [](std::string s) { return fs_utils::path_exists(s); }));

    if (there_is_a_bad_path) {
        return;
    }

    std::filesystem::path output_header_dir = std::filesystem::path(output_header_path).parent_path();

    // TODO: replace this with an attribute
    // we need this because the metaprogram stores a an object for each source header pair meta function collection
    struct ObjectFunction {
        std::string object_name;
        MetaFunction function;
    };
    std::unordered_map<std::string, std::vector<ObjectFunction>> return_type_to_invokers_that_return_it;
    std::unordered_map<std::string, std::vector<ObjectFunction>> return_type_to_deferred_invokers_that_return_it;

    std::vector<std::string> header_paths_of_other_string_invokers;

    std::vector<MetaCodeCollection> generated_mcc_for_each_header_source_pair;

    for (const auto &setting : settings) {
        std::string meta_code_path = fs_utils::get_containing_directory(setting.header_file_path) + "/meta/" +
                                     fs_utils::get_filename_from_path(setting.header_file_path);
        std::string rel_path = fs_utils::get_relative_path(output_header_dir, meta_code_path);
        auto rel_include = "#include \"" + rel_path + "\"";
        header_paths_of_other_string_invokers.push_back(rel_include);
        // NOTE: important call
        MetaCodeCollection mfc_that_was_just_written = generate_string_invokers_from_header_and_source(setting);
        generated_mcc_for_each_header_source_pair.push_back(mfc_that_was_just_written);

        // WARN: assuming each one has at least one class
        MetaClass meta_class_for_source_header_pair = mfc_that_was_just_written.classes.at(0);

        for (const auto &meta_method : meta_class_for_source_header_pair.methods) {
            auto fun = meta_method.function;

            bool is_string_to_type_invoker = text_utils::starts_with(fun.signature.name, "invoker_that_returns");
            // WARN: this is a sketchy way of extracting the type with assumptions
            std::string return_type = text_utils::replace_substring(fun.signature.name, "invoker_that_returns", "");
            if (is_string_to_type_invoker) {
                return_type_to_invokers_that_return_it[return_type].push_back(
                    {text_utils::pascal_to_snake_case(meta_class_for_source_header_pair.name), fun});
            }

            bool is_string_to_type_deferred_invoker =
                text_utils::starts_with(fun.signature.name, "deferred_invoker_that_returns");
            // WARN: this is a sketchy way of extracting the type with assumptions
            std::string deferred_return_type =
                text_utils::replace_substring(fun.signature.name, "deferred_invoker_that_returns", "");
            if (is_string_to_type_deferred_invoker) {
                return_type_to_deferred_invokers_that_return_it[deferred_return_type].push_back(
                    {text_utils::pascal_to_snake_case(meta_class_for_source_header_pair.name), fun});
            }
        }
    }

    // NOTE: now we want to collect all the functions that we can call, which is given by the input collection
    std::vector<MetaVariable> all_meta_function_signatures_from_sub_string_invokers =
        collection_utils::join_all_vectors(collection_utils::map_vector(
            generated_mcc_for_each_header_source_pair, [](MetaCodeCollection mfc) { return mfc.variables; }));

    MetaCodeCollection meta_program_mcc;
    meta_utils::MetaClass meta_class("MetaProgram");

    meta_program_mcc.name = "meta_program";
    meta_program_mcc.name_space = "meta_program";

    struct Helper {
        std::string lambda_source;
        std::string func_name;
        std::string return_type;
    };

    for (const auto &mt : all_types) {

        for (const auto &include : mt.includes_required) {
            meta_program_mcc.includes_required_for_declaration.push_back(include.str(output_header_dir));
        }

        std::vector<Helper> func_sources = {
            {mt.type_to_string_func_lambda, to_string_function_name(mt.base_type_name), "std::string"},
            {mt.string_to_type_func_lambda, from_string_function_name(mt.base_type_name), mt.base_type_name},
            {mt.serialize_type_func_lambda, serialize_function_name(mt.base_type_name), "std::vector<uint8_t>"},
            {mt.size_when_serialized_bytes_func_lambda, size_when_serialized_function_name(mt.base_type_name),
             "size_t"},
            {mt.deserialize_type_func_lambda, deserialize_function_name(mt.base_type_name), mt.base_type_name}};

        for (const auto &[lambda_source, func_name, return_type] : func_sources) {
            auto regular_func = lambda_to_function(lambda_source, func_name, return_type);
            MetaFunction mf(regular_func);
            meta_class.add_method(mf);
        }
    }

    // top_level_invoker_mfc.variables.push_back(vector_of_meta_function_signature_var_names);

    meta_program_mcc.includes_required_for_declaration = collection_utils::join_vectors(
        meta_program_mcc.includes_required_for_declaration, header_paths_of_other_string_invokers);
    meta_program_mcc.includes_required_for_declaration.push_back(optional_include);
    meta_program_mcc.includes_required_for_declaration.push_back(
        create_local_include(fs_utils::get_relative_path(output_header_dir, "src/utility/meta_utils/meta_utils.hpp")));
    meta_program_mcc.includes_required_for_definition.push_back("#include \"meta_program.hpp\"");
    meta_program_mcc.includes_required_for_declaration.push_back(
        create_local_include(fs_utils::get_relative_path(output_header_dir, "src/utility/user_input/user_input.hpp")));

    auto create_func_that_sequentially_tries_funcs_that_return_opt =
        [&](std::unordered_map<std::string, std::vector<ObjectFunction>> &return_type_to_invokers_that_return_it) {
            for (const auto &[return_type, object_functions] : return_type_to_invokers_that_return_it) {
                if (object_functions.empty())
                    continue;

                // therefore we know that obj funs is non empty

                text_utils::MultilineStringAccumulator mla;

                auto object_function = object_functions.at(0);
                MetaFunction mf = object_function.function;

                // declare the return value, this is why we need at least one
                mla.add(mf.signature.return_type, " val;");

                // NOTE: then optionally try and run each possible one sequentially.
                for (const auto &object_function : object_functions) {
                    auto mf = object_function.function;
                    mla.add("val = ", object_function.object_name + ".", mf.signature.name, "(invocation);");
                    mla.add("if (val)");
                    mla.add("    return val;");
                    mla.add("");
                }
                mla.add("return std::nullopt;");
                MetaFunction top_level_mf(mf.signature, mla, "");
                meta_class.add_method(MetaMethod(top_level_mf));
                // top_level_invoker_mfc.add_function();
            }
        };

    create_func_that_sequentially_tries_funcs_that_return_opt(return_type_to_invokers_that_return_it);
    create_func_that_sequentially_tries_funcs_that_return_opt(return_type_to_deferred_invokers_that_return_it);

    meta_class.add_method(MetaMethod(create_interactive_invoker()));

    meta_class.add_method(MetaMethod(create_list_all_available_functions(generated_mcc_for_each_header_source_pair)));

    MetaParameter vector_of_meta_types("std::vector<meta_utils::MetaType> concrete_types");
    MetaConstructor mc(meta_class.name, {vector_of_meta_types}, "", AccessSpecifier::Public,
                       {"concrete_types(concrete_types)"});
    meta_class.constructors.push_back(mc);

    MetaVariable concrete_types("std::vector<meta_utils::MetaType> ", "concrete_types", "");
    MetaAttribute concrete_types_reference(concrete_types, AccessSpecifier::Public);
    meta_class.add_attribute(concrete_types_reference);

    // NOTE: this adds each header pair mcc class to the meta program.
    for (const auto &mcc : generated_mcc_for_each_header_source_pair) {
        // NOTE: we use the assumption that each generated mccs has exactly one class right now, which is a bit
        // sketchy
        MetaClass mc = mcc.classes.at(0);

        std::string var_name;
        if (not mcc.name_space.empty()) {
            var_name = mcc.name_space + "::" + mc.name;
        } else {
            var_name = mc.name;
        }

        MetaVariable mv(var_name, text_utils::pascal_to_snake_case(mc.name), "concrete_types",
                        MetaVariable::InitStyle::Brace);
        MetaAttribute ma(mv, AccessSpecifier::Public);
        meta_class.add_attribute(ma);
    }

    meta_program_mcc.classes.push_back(meta_class);

    meta_program_mcc.write_to_header_and_source(output_header_path, output_source_path);
}

MetaCodeCollection
generate_string_invokers_from_header_and_source(const StringInvokerGenerationSettingsForHeaderSource &sigsfhs) {
    return generate_string_invokers_from_header_and_source(
        sigsfhs.header_file_path, sigsfhs.source_file_path, sigsfhs.create_top_level_invoker,
        sigsfhs.create_type_grouped_invokers, sigsfhs.string_signatures_for_potential_filtering, sigsfhs.mode);
}

MetaCodeCollection generate_string_invokers_from_header_and_source(
    const std::string &input_header_path, const std::string &input_source_path, bool create_top_level_invoker,
    bool create_type_grouped_invokers, const std::vector<std::string> &string_signatures_to_filter_on,
    FilterMode mode) {

    const std::string output_name_prefix = "meta_";

    meta_utils::MetaCodeCollection input_collection(input_header_path, input_source_path,
                                                    string_signatures_to_filter_on, mode);

    meta_utils::MetaCodeCollection output_collection;

    bool input_collection_doesnt_use_namespace = input_collection.name_space == "";
    output_collection.name_space =
        output_name_prefix +
        (input_collection_doesnt_use_namespace ? input_collection.name : input_collection.name_space);
    output_collection.name = output_name_prefix + input_collection.name;

    auto class_name = text_utils::snake_to_pascal_case(output_name_prefix + input_collection.name);
    meta_utils::MetaClass meta_class(class_name);
    MetaParameter vector_of_meta_types("std::vector<meta_utils::MetaType> &concrete_types");
    MetaConstructor mc(class_name, {vector_of_meta_types}, "", AccessSpecifier::Public,
                       {"concrete_types(concrete_types)"});
    meta_class.constructors.push_back(mc);

    MetaVariable concrete_types("std::vector<meta_utils::MetaType> &", "concrete_types", "");
    MetaAttribute concrete_types_reference(concrete_types, AccessSpecifier::Public);
    meta_class.add_attribute(concrete_types_reference);

    output_collection.includes_required_for_declaration =
        get_system_headers(input_collection.includes_required_for_declaration);

    output_collection.includes_required_for_declaration.push_back(meta_utils::string_include);
    output_collection.includes_required_for_declaration.push_back(meta_utils::optional_include);

    std::filesystem::path input_header_dir = std::filesystem::path(input_header_path).parent_path();
    std::filesystem::path output_dir = input_header_dir / "meta";

    auto meta_utils_rel_path = fs_utils::get_relative_path(output_dir, "src/utility/meta_utils/meta_utils.hpp");

    auto rel_glm_utils_path = fs_utils::get_relative_path(output_dir, "src/utility/glm_utils/glm_utils.hpp");
    auto rel_glm_printing_path = fs_utils::get_relative_path(output_dir, "src/utility/glm_printing/glm_printing.hpp");

    output_collection.includes_required_for_declaration = {
        create_local_include(meta_utils_rel_path),
        "#include \"../" + std::filesystem::path(input_header_path).filename().string() + "\"",
        // "#include \"" + std::string(rel_glm_utils_path) + "\"",
        // "#include \"" + std::string(rel_glm_printing_path) + "\"",
        meta_utils::regex_include, meta_utils::optional_include};

    // output_collection.includes_required_for_definition = {
    //     "#include \"" + std::filesystem::path(input_header_path).filename().string() + "\"",
    //     "#include \"../" + std::filesystem::path(input_header_path).filename().string() + "\"",
    //     meta_utils::regex_include};

    // auto string_invokers = generate_string_invokers(input_collection.functions);
    auto string_invokers = generate_string_invokers(input_collection.declared_function_signatures_in_header_file);

    // auto meta_function_signature_variables = generate_meta_function_signature_variables(input_collection.functions);
    auto meta_function_signature_variables =
        generate_meta_function_signature_variables(input_collection.declared_function_signatures_in_header_file);
    collection_utils::for_each_in_vector(meta_function_signature_variables, [&](MetaVariable &mv) {
        mv.name_space = output_collection.name_space;
        mv.init_style = MetaVariable::InitStyle::Brace;
    });
    collection_utils::for_each_in_vector(meta_function_signature_variables, [&](MetaVariable &mv) {
        meta_class.add_attribute(MetaAttribute(mv, AccessSpecifier::Public));
    });

    MetaVariable all_meta_function_signatures_vector(
        "std::vector<meta_utils::MetaFunctionSignature>", "all_meta_function_signatures",
        text_utils::surround(text_utils::join(collection_utils::map_vector(meta_function_signature_variables,
                                                                           [](MetaVariable mv) { return mv.name; }),
                                              ", "),
                             text_utils::left_brace, text_utils::right_brace),
        MetaVariable::InitStyle::Assignment);

    meta_class.add_attribute(MetaAttribute(all_meta_function_signatures_vector, AccessSpecifier::Public));

    // output_collection.variables = generate_meta_function_signature_variables(input_collection.functions);

    if (create_type_grouped_invokers) {
        // NOTE: that this operates on the input collections original functions which is fine
        auto type_grouped_invokers = generate_type_grouped_invokers(
            input_collection.declared_function_signatures_in_header_file, create_top_level_invoker);
        for (const auto &type_grouped_invoker : type_grouped_invokers) {
            meta_utils::MetaFunction full_invoker(type_grouped_invoker, output_collection.name_space);
            meta_utils::MetaMethod method(full_invoker);
            // output_collection.add_function(full_invoker);
            meta_class.add_method(method);
        }
    }

    auto all_needed_functions = string_invokers;

    // we also need ones that return optional strings.
    if (create_top_level_invoker) {
        // auto string_invoker_to_strings = generate_string_invokers_to_string(input_collection.functions);
        auto string_invoker_to_strings =
            generate_string_invokers_to_string(input_collection.declared_function_signatures_in_header_file);
        for (const auto inv : string_invoker_to_strings) {
            all_needed_functions.push_back(inv);
        }

        auto full_invoker_str = meta_utils::generate_string_invoker_for_function_collection_that_has_same_return_type(
            input_collection.declared_function_signatures_in_header_file, "std::string", "_string_invoker_to_string");
        meta_utils::MetaFunction full_invoker(full_invoker_str, output_collection.name_space);
        meta_class.add_method(MetaMethod(full_invoker));
        meta_class.add_method(MetaMethod(generate_interactive_invoker()));
        // output_collection.add_function(full_invoker);
        // output_collection.add_function(generate_interactive_invoker());
    }

    for (const auto &si : all_needed_functions) {
        meta_class.add_method(MetaMethod(si));
        // output_collection.add_function(si);
    }

    std::string base_filename = std::filesystem::path(input_header_path).stem().string();
    std::filesystem::path output_header = output_dir / (base_filename + ".hpp");
    std::filesystem::path output_source = output_dir / (base_filename + ".cpp");

    output_collection.classes.push_back(meta_class);
    output_collection.write_to_header_and_source(output_header, output_source);

    return output_collection;
}

bool is_system_header(const std::string &line) {
    std::string trimmed = trim(line);
    return trimmed.starts_with("#include <") && trimmed.ends_with(">");
}

bool is_local_header(const std::string &line) {
    std::string trimmed = trim(line);
    return trimmed.starts_with("#include \"") && trimmed.ends_with("\"");
}

std::vector<std::string> get_system_headers(const std::vector<std::string> &headers) {
    std::vector<std::string> system_headers;
    for (const auto &header : headers) {
        if (is_system_header(header)) {
            system_headers.push_back(trim(header));
        }
    }
    return system_headers;
}

MetaFunction generate_interactive_invoker() {
    // NOTE: one day I think we can remove the dep on available types
    MetaFunction interactive_invoker(R"(
void start_interactive_invoker() {
    std::cout << "Enter function invocation strings (type 'quit' to exit):\n";

    std::string input;
    while (true) {
        std::cout << "> ";
        std::getline(std::cin, input);

        if (input == "quit")
            break;

        std::optional<std::string> result = invoker_that_returns_std_string(input);
        if (result.has_value()) {
            std::cout << "Result: " << result.value() << "\n";
        } else {
            std::cout << "Invocation failed.\n";
        }
    }

    std::cout << "Goodbye!\n";
})");
    return interactive_invoker;
}

} // namespace meta_utils
